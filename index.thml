<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Project Elmo 002.1</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg1:#1f7a1f; --bg2:#2fb02f; --bg3:#9fe29f;
    --tile:60px;
  }
  html,body{height:100%;margin:0}
  body{font-family:system-ui,Segoe UI,Roboto,Arial;display:flex;flex-direction:column;align-items:center;background:linear-gradient(120deg,var(--bg1),var(--bg2));padding:18px;color:#fff}
  header{display:flex;gap:12px;align-items:center;width:100%;max-width:980px}
  h1{margin:0;font-size:20px}
  .vbadge{background:linear-gradient(90deg,#fff6e0,#ffe2a6);color:#6b3f00;padding:6px 10px;border-radius:999px;font-weight:700}
  #controls{display:flex;gap:8px;margin-top:12px;align-items:center}
  button,input,select{padding:8px;border-radius:8px;border:0}
  #board{display:grid;grid-template-columns:repeat(5,var(--tile));grid-gap:6px;margin-top:14px}
  .cell{width:var(--tile);height:var(--tile);display:flex;align-items:center;justify-content:center;border-radius:8px;cursor:pointer}
  .white{background:#fff;color:#111}.black{background:#333;color:#fff}
  .captured-red{background:#ff6b6b}.captured-blue{background:#6bb2ff}
  .pawn{font-size:28px;filter:drop-shadow(0 6px 10px rgba(0,0,0,0.28));cursor:grab;user-select:none}
  #status{margin-top:10px;min-height:20px}
  .small{font-size:12px;opacity:0.9}
  .save-indicator{font-size:12px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.06);color:#fff;margin-left:8px}
  .changelog{margin-left:auto;background:rgba(0,0,0,0.12);padding:8px;border-radius:8px;font-size:13px}
</style>
</head>
<body>
  <header>
    <div style="display:flex;align-items:center;gap:12px">
      <h1>Project Elmo</h1>
      <div class="vbadge">002.1</div>
      <div class="save-indicator" id="autosaveIndicator">No save</div>
    </div>

    <div class="changelog" aria-hidden="false">
      <strong>Changelog</strong>
      <div class="small">002.1: localStorage autosave; manual save/load; clear saved state; win = 3 captured tiles in a row</div>
    </div>
  </header>

  <div id="controls">
    <button id="resetBtn">Reset</button>
    <button id="undoBtn" disabled>Undo</button>
    <button id="redoBtn" disabled>Redo</button>
    <button id="saveBtn">Save</button>
    <button id="loadBtn">Load</button>
    <button id="clearSaveBtn">Clear Save</button>
    <label class="small" style="margin-left:8px">Autosave:
      <select id="autosaveToggle" aria-label="Autosave">
        <option value="on">On</option>
        <option value="off">Off</option>
      </select>
    </label>
  </div>

  <div id="status" class="small" aria-live="polite"></div>

  <div id="board" role="grid" aria-label="game board"></div>

<script>
/* Project Elmo 002.1 â€” persistent snapshots in localStorage
   - Saves: undoStack, redoStack, current snapshot, scores, currentPlayer, chain info
   - Keys: projectElmo_002_1_saved
*/

const LOCAL_KEY = 'projectElmo_002_1_saved_v1';

const board = document.getElementById('board');
const status = document.getElementById('status');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const saveBtn = document.getElementById('saveBtn');
const loadBtn = document.getElementById('loadBtn');
const clearSaveBtn = document.getElementById('clearSaveBtn');
const autosaveIndicator = document.getElementById('autosaveIndicator');
const autosaveToggle = document.getElementById('autosaveToggle');

let currentPlayer = 'red';
let dragged = null;
let chainMode = false;
let chainPawn = null;
let chainCount = 0;
let scores = { red:0, blue:0 };

const undoStack = [];
const redoStack = [];
let suppressSnapshots = false;

// Audio helper (kept simple)
let audioCtx = null;
function ensureAudioContext(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }

// Pawn factory
function makePawn(color){
  const pawn = document.createElement('div');
  pawn.className = 'pawn';
  pawn.textContent = color === 'red' ? 'ðŸ˜ˆ' : 'ðŸ˜‡';
  pawn.draggable = true;
  pawn.dataset.color = color;

  pawn.addEventListener('dragstart', (ev) => {
    if (pawn.dataset.color !== currentPlayer) { ev.preventDefault(); return; }
    if (chainMode && pawn !== chainPawn) { ev.preventDefault(); return; }
    dragged = pawn; pawn.classList.add('dragging');
    try { ev.dataTransfer.setData('text/plain','drag'); } catch(e){}
    ensureAudioContext();
  });
  pawn.addEventListener('dragend', () => pawn.classList.remove('dragging'));

  pawn.addEventListener('pointerdown', (ev) => {
    if (pawn.dataset.color !== currentPlayer) return;
    if (chainMode && pawn !== chainPawn) return;
    try { pawn.setPointerCapture && pawn.setPointerCapture(ev.pointerId); } catch(e){}
    dragged = pawn; pawn.classList.add('dragging');
  });
  pawn.addEventListener('pointerup', (ev) => {
    try { pawn.releasePointerCapture && pawn.releasePointerCapture(ev.pointerId); } catch(e){}
    setTimeout(()=> pawn.classList.remove('dragging'),40);
  });

  return pawn;
}

// Snapshot helpers
function takeSnapshot(){
  const boardArr = new Array(25).fill(null);
  for(let i=0;i<25;i++){
    const cell = board.children[i];
    if(!cell) continue;
    const pawnEl = cell.querySelector('.pawn');
    if(pawnEl){
      boardArr[i] = { pawn: pawnEl.dataset.color, captured: cell.classList.contains('captured-red') || cell.classList.contains('captured-blue') };
    } else if (cell.classList.contains('captured-red')){
      boardArr[i] = { pawn:'red', captured:true };
    } else if (cell.classList.contains('captured-blue')){
      boardArr[i] = { pawn:'blue', captured:true };
    } else {
      boardArr[i] = null;
    }
  }
  return {
    board: boardArr,
    currentPlayer,
    scores: { red: scores.red, blue: scores.blue },
    chainMode: !!chainMode,
    chainCount: chainCount || 0,
    chainPawnIdx: (chainPawn && chainPawn.parentElement) ? Number(chainPawn.parentElement.dataset.index) : null,
    ts: Date.now()
  };
}

function applySnapshot(snapshot){
  if(!snapshot || !Array.isArray(snapshot.board)) return;
  for(let i=0;i<25;i++){
    const cell = board.children[i];
    if(!cell) continue;
    cell.innerHTML = '';
    cell.classList.remove('captured-red','captured-blue','white','black');
    cell.classList.add((Math.floor(i/5) + i%5) % 2 === 0 ? 'white' : 'black');
  }
  for(let i=0;i<25;i++){
    const entry = snapshot.board[i];
    const cell = board.children[i];
    if(!cell) continue;
    if(entry && entry.pawn){
      if(entry.captured) cell.classList.add(entry.pawn === 'red' ? 'captured-red' : 'captured-blue');
      const pawn = makePawn(entry.pawn);
      cell.appendChild(pawn);
    }
  }
  currentPlayer = snapshot.currentPlayer;
  scores = { red: snapshot.scores.red, blue: snapshot.scores.blue };
  chainMode = !!snapshot.chainMode;
  chainCount = snapshot.chainCount || 0;
  chainPawn = null;
  if(typeof snapshot.chainPawnIdx === 'number' && snapshot.chainPawnIdx >= 0 && snapshot.chainPawnIdx < 25){
    const cpCell = board.children[snapshot.chainPawnIdx];
    if(cpCell) chainPawn = cpCell.querySelector('.pawn');
  }
  updateStatus();
  updateUndoRedoButtons();
}

// record / restore stacks
function recordSnapshot(){
  if(suppressSnapshots) return;
  undoStack.push(takeSnapshot());
  redoStack.length = 0;
  updateUndoRedoButtons();
  maybeAutosave();
}

function updateUndoRedoButtons(){
  undoBtn.disabled = undoStack.length <= 1;
  redoBtn.disabled = redoStack.length === 0;
}

function undo(){
  if(undoStack.length <= 1) return;
  const cur = undoStack.pop();
  redoStack.push(cur);
  suppressSnapshots = true;
  try{
    const prev = undoStack[undoStack.length - 1];
    if(prev) applySnapshot(prev);
  } finally { suppressSnapshots = false; }
  updateStatus('Undid action');
  maybeAutosave();
}

function redo(){
  if(redoStack.length === 0) return;
  const snap = redoStack.pop();
  suppressSnapshots = true;
  try{
    applySnapshot(snap);
    undoStack.push(snap);
  } finally { suppressSnapshots = false; }
  updateStatus('Redid action');
  maybeAutosave();
}

// board init and interaction
function resetBoard(){
  board.innerHTML = '';
  scores = { red:0, blue:0 };
  currentPlayer = 'red';
  dragged = null; chainMode = false; chainPawn = null; chainCount = 0;
  for(let i=0;i<25;i++){
    const cell = document.createElement('div');
    cell.className = 'cell ' + (((Math.floor(i/5) + i%5) % 2 === 0) ? 'white' : 'black');
    cell.dataset.index = i;
    cell.addEventListener('click', ()=> onCellClick(cell));
    cell.addEventListener('dragover', e=>e.preventDefault());
    cell.addEventListener('drop', e=> handleDrop(e, cell));
    board.appendChild(cell);
  }
  undoStack.length = 0; redoStack.length = 0;
  undoStack.push(takeSnapshot());
  updateStatus();
  updateUndoRedoButtons();
  maybeAutosave();
}

function onCellClick(cell){
  const idx = Number(cell.dataset.index);
  const row = Math.floor(idx / 5);
  if((currentPlayer === 'red' && row !== 4) || (currentPlayer==='blue' && row !== 0)) return;
  if(cell.querySelector('.pawn')) return;
  const pawn = makePawn(currentPlayer);
  cell.appendChild(pawn);
  recordSnapshot();
  switchTurn();
}

function isValidMove(dx,dy){ return dx <= 1 && dy <= 1 && (dx + dy > 0); }
function isValidCapture(dx,dy){ return dx === 1 && dy === 1; }

function availableDiagonalCapturesFromCell(cellElem){
  if(!cellElem) return [];
  const idx = Number(cellElem.dataset.index); const x = idx % 5; const y = Math.floor(idx/5);
  const dirs = [[-1,-1],[1,-1],[-1,1],[1,1]];
  const out = [];
  const pawn = cellElem.querySelector('.pawn'); if(!pawn) return [];
  for(const [dx,dy] of dirs){
    const nx = x + dx, ny = y + dy;
    if(nx < 0 || nx >=5 || ny < 0 || ny >=5) continue;
    const nIdx = ny*5 + nx; const neighbor = board.children[nIdx];
    const occ = neighbor.querySelector('.pawn');
    if(occ && occ.dataset.color !== pawn.dataset.color) out.push({ idx: nIdx, cell: neighbor });
  }
  return out;
}

function handleDrop(e, targetCell){
  e.preventDefault();
  if(!dragged) return;
  const pawn = dragged;
  const fromCell = pawn.parentElement;
  if(!fromCell){ dragged = null; return; }
  const fromIdx = Number(fromCell.dataset.index), toIdx = Number(targetCell.dataset.index);
  const dx = Math.abs((toIdx % 5) - (fromIdx % 5));
  const dy = Math.abs(Math.floor(toIdx / 5) - Math.floor(fromIdx / 5));
  if(!isValidMove(dx,dy)) return;
  const existing = targetCell.querySelector('.pawn');

  if(existing && existing.dataset.color !== pawn.dataset.color && isValidCapture(dx,dy)){
    existing.classList.add('captured');
    setTimeout(()=>{
      targetCell.innerHTML = '';
      targetCell.classList.remove('white','black','captured-red','captured-blue');
      targetCell.classList.add(pawn.dataset.color === 'red' ? 'captured-red' : 'captured-blue');
      targetCell.appendChild(pawn);
      pawn.classList.remove('dragging');

      scores[currentPlayer]++; chainCount++;

      // small feedback
      showCaptureEffect(targetCell, pawn.dataset.color);
      maybePlaySound(chainCount);

      const further = availableDiagonalCapturesFromCell(targetCell);
      if(further.length > 0){
        chainMode = true; chainPawn = pawn; dragged = pawn; recordSnapshot(); updateStatus(`Chain x${chainCount}`);
      } else {
        chainMode = false; chainPawn = null; chainCount = 0; dragged = null; recordSnapshot();
        if(checkWinCapturedThreeInRow(currentPlayer)) return;
        switchTurn();
      }
    }, 200);
    return;
  }

  if(existing) return;
  targetCell.appendChild(pawn); pawn.classList.remove('dragging'); recordSnapshot(); dragged = null;
  if(!checkWinCapturedThreeInRow(currentPlayer)) switchTurn();
}

function switchTurn(){ currentPlayer = currentPlayer === 'red' ? 'blue' : 'red'; updateStatus(); dragged = null; chainMode = false; chainPawn = null; chainCount = 0; }

// capture visuals & audio
function showCaptureEffect(cell,color){
  // very small visual; reuse simple background flash
  cell.style.transition = 'transform .18s ease, box-shadow .18s ease';
  cell.style.transform = 'scale(1.05)';
  setTimeout(()=>{ cell.style.transform = ''; }, 160);
}
function maybePlaySound(level){ try{ ensureAudioContext(); }catch(e){} }

// NEW WIN: three captured tiles in a row (horizontal, vertical, diagonal)
function capturedOwnerOf(index){
  const cell = board.children[index];
  if(!cell) return null;
  if(cell.classList.contains('captured-red')) return 'red';
  if(cell.classList.contains('captured-blue')) return 'blue';
  return null;
}

function checkCapturedRunOfThreeForColor(color){
  // horizontal
  for(let r=0;r<5;r++){
    for(let c=0;c<=2;c++){
      const a = capturedOwnerOf(r*5 + c);
      const b = capturedOwnerOf(r*5 + c + 1);
      const c2 = capturedOwnerOf(r*5 + c + 2);
      if(a === color && b === color && c2 === color) return true;
    }
  }
  // vertical
  for(let c=0;c<5;c++){
    for(let r=0;r<=2;r++){
      const a = capturedOwnerOf(r*5 + c);
      const b = capturedOwnerOf((r+1)*5 + c);
      const c2 = capturedOwnerOf((r+2)*5 + c);
      if(a === color && b === color && c2 === color) return true;
    }
  }
  // down-right diagonals
  for(let r=0;r<=2;r++){
    for(let c=0;c<=2;c++){
      const a = capturedOwnerOf(r*5 + c);
      const b = capturedOwnerOf((r+1)*5 + (c+1));
      const c2 = capturedOwnerOf((r+2)*5 + (c+2));
      if(a === color && b === color && c2 === color) return true;
    }
  }
  // up-right diagonals
  for(let r=2;r<5;r++){
    for(let c=0;c<=2;c++){
      const a = capturedOwnerOf(r*5 + c);
      const b = capturedOwnerOf((r-1)*5 + (c+1));
      const c2 = capturedOwnerOf((r-2)*5 + (c+2));
      if(a === color && b === color && c2 === color) return true;
    }
  }
  return false;
}

function checkWinCapturedThreeInRow(playerColor){
  if(checkCapturedRunOfThreeForColor(playerColor)){
    endGame(playerColor);
    return true;
  }
  return false;
}

function endGame(playerColor){
  updateStatus(`ðŸ† ${playerColor === 'red' ? 'ðŸ˜ˆ' : 'ðŸ˜‡'} wins â€” three captured tiles in a row!`);
  // disable further drops
  board.querySelectorAll('.cell').forEach(cell => cell.removeEventListener('drop', handleDrop));
}

// status
function updateStatus(msg=''){
  if(msg){ status.textContent = msg; return; }
  status.textContent = `Turn: ${currentPlayer==='red'?'ðŸ˜ˆ (red)':'ðŸ˜‡ (blue)'} | Score ðŸ˜ˆ: ${scores.red} â¬„ ðŸ˜‡: ${scores.blue}` + (chainMode ? ' â€” chain active' : '');
}

// Persistence: save/load/clear
function makeSavePayload(){
  return {
    undoStack,
    redoStack,
    currentPlayer,
    scores,
    chainMode,
    chainCount,
    timestamp: Date.now()
  };
}
function saveNow(manual=false){
  try{
    const payload = makeSavePayload();
    const ser = JSON.stringify(payload);
    localStorage.setItem(LOCAL_KEY, ser);
    autosaveIndicator.textContent = manual ? 'Saved' : 'Autosaved';
    autosaveIndicator.style.opacity = '1';
    setTimeout(()=> autosaveIndicator.style.opacity = '0.8', 800);
  }catch(e){ console.warn('Save failed', e); autosaveIndicator.textContent = 'Save error'; }
}
function loadNow(){
  try{
    const raw = localStorage.getItem(LOCAL_KEY);
    if(!raw) { updateStatus('No saved state'); return false; }
    const obj = JSON.parse(raw);
    // restore stacks and apply top snapshot if present
    undoStack.length = 0; redoStack.length = 0;
    if(Array.isArray(obj.undoStack)) {
      for(const s of obj.undoStack) undoStack.push(s);
    }
    if(Array.isArray(obj.redoStack)) {
      for(const s of obj.redoStack) redoStack.push(s);
    }
    if(undoStack.length > 0) applySnapshot(undoStack[undoStack.length - 1]);
    else resetBoard();
    updateStatus('Loaded saved state');
    return true;
  }catch(e){ console.warn('Load failed', e); updateStatus('Load error'); return false; }
}
function clearSave(){
  localStorage.removeItem(LOCAL_KEY);
  autosaveIndicator.textContent = 'No save';
  updateStatus('Cleared saved data');
}

// autosave policy
function maybeAutosave(){
  if(autosaveToggle.value === 'on') saveNow(false);
}

// wire UI
resetBtn.addEventListener('click', ()=> { resetBoard(); saveNow(true); });
undoBtn.addEventListener('click', ()=> { undo(); saveNow(true); });
redoBtn.addEventListener('click', ()=> { redo(); saveNow(true); });
saveBtn.addEventListener('click', ()=> { saveNow(true); });
loadBtn.addEventListener('click', ()=> { loadNow(); });
clearSaveBtn.addEventListener('click', ()=> { clearSave(); });

autosaveToggle.addEventListener('change', ()=> {
  if(autosaveToggle.value === 'on') autosaveIndicator.textContent = 'Autosave on';
  else autosaveIndicator.textContent = 'Autosave off';
});

// initialization: build board and restore if available
function init(){
  // build grid
  board.innerHTML = '';
  for(let i=0;i<25;i++){
    const cell = document.createElement('div');
    cell.className = 'cell ' + (((Math.floor(i/5) + i%5) % 2 === 0) ? 'white' : 'black');
    cell.dataset.index = i;
    cell.addEventListener('click', ()=> onCellClick(cell));
    cell.addEventListener('dragover', e=>e.preventDefault());
    cell.addEventListener('drop', e=> handleDrop(e, cell));
    board.appendChild(cell);
  }
  // try load
  const have = loadNow();
  if(!have){
    // no saved state â€” start fresh
    undoStack.length = 0; redoStack.length = 0;
    undoStack.push(takeSnapshot());
    updateStatus();
    updateUndoRedoButtons();
    autosaveIndicator.textContent = 'No save';
  } else {
    autosaveIndicator.textContent = 'Loaded';
  }
  // ensure autosave on by default
  autosaveToggle.value = 'on';
  if(autosaveToggle.value === 'on') autosaveIndicator.textContent = autosaveIndicator.textContent === 'No save' ? 'Autosave on' : autosaveIndicator.textContent;
}

init();

// expose debug
window.__PE = { undoStack, redoStack, takeSnapshot: ()=> undoStack[undoStack.length-1], applySnapshot, saveNow, loadNow, clearSave };

</script>
</body>
</html>
