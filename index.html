<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Kings Plane v005.1 ‚Äî Attack-Tac-</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    
    --scale:1.25;
    --bg1:#0b6b2d;
    --bg2:#18a058;
    --tile:calc(60px * var(--scale));
    /* Tile theming for embossed appearance */
    --tile-border: rgba(0,0,0,0.14);
    --tile-highlight: rgba(255,255,255,0.18);
    --tile-white-top: linear-gradient(180deg,#ffffff 0%, #f1f1f1 40%, #e6e6e6 100%);
    --tile-black-top: linear-gradient(180deg,#3a3a3a 0%, #2f2f2f 50%, #242424 100%);
    /* Rim variables (green theme) */
    --tile-gold-1: #ffffff; /* light (now white) highlight */
    --tile-gold-2: #ffffff; /* deeper (now white) */
  --tile-gold-edge: transparent; /* rim removed */
  --tile-gold-glow: transparent; /* glow removed */
    --tile-gold-width: 0px; /* rim width set to 0 to disable edge */
  }
  html,body{height:100%;margin:0}
  body{
    font-family:system-ui,Segoe UI,Roboto,Arial;
    background:linear-gradient(150deg,var(--bg1) 0%, #1f9a4f 40%, var(--bg2) 70%);
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:calc(18px * var(--scale));
    box-sizing:border-box;
    overflow:hidden;
  }

  /* Prevent any accidental text selection while interacting with the game (drag/drop) */
  body, .app, .panel-backdrop, #board, .cell, .pawn, .emoji-option, .emoji-chooser-title, #status, .victory-card {
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  /* Allow text selection in inputs explicitly (team name inputs) */
  input, textarea, .team-name-input {
    -webkit-user-select: text;
    -ms-user-select: text;
    user-select: text;
  }

  .app { width:100%; max-width:calc(820px * var(--scale)); display:flex; flex-direction:column; align-items:center; gap:calc(12px * var(--scale)); position:relative; z-index:2; }
  header{display:flex;flex-direction:column;align-items:center;gap:calc(8px * var(--scale));width:100%}
  .titleRow {display:flex;align-items:center;gap:calc(12px * var(--scale))}
  h1{margin:0;font-size:calc(20px * var(--scale))}
  .vbadge{background:linear-gradient(90deg,#fff6e0,#ffe2a6);color:#6b3f00;padding:calc(6px * var(--scale)) calc(10px * var(--scale));border-radius:999px;font-weight:700;font-size:calc(13px * var(--scale))}

  .panel-backdrop { width:100%; background: rgba(0,0,0,0.10); border-radius:calc(12px * var(--scale)); padding:calc(14px * var(--scale)); box-shadow: 0 12px 38px rgba(0,0,0,0.14); backdrop-filter: blur(5px); display:flex; flex-direction:column; align-items:center; gap:calc(12px * var(--scale)); }

  #controls{display:flex;flex-wrap:wrap;gap:calc(8px * var(--scale));justify-content:center;width:100%}
  /* Group for primary actions (New / Reset) to match UI theming */
  .primary-actions{
    display:flex;
    gap:calc(8px * var(--scale));
    align-items:center;
    padding:calc(6px * var(--scale));
    border-radius:calc(10px * var(--scale));
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 8px 26px rgba(0,0,0,0.12);
  }
  /* keep layout consistent on narrow viewports */
  @media (max-width:520px){ .primary-actions{ width:100%; justify-content:center } }
  /* secondary group for undo/redo buttons ‚Äî match primary-actions styling */
  .secondary-actions{
    display:flex;
    gap:calc(8px * var(--scale));
    align-items:center;
    padding:calc(6px * var(--scale));
    border-radius:calc(10px * var(--scale));
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 8px 26px rgba(0,0,0,0.12);
  }
  @media (max-width:520px){ .secondary-actions{ width:100%; justify-content:center } }
  /* tertiary group for AI / Theme / Rules buttons ‚Äî match primary-actions styling */
  .tertiary-actions{
    display:flex;
    gap:calc(8px * var(--scale));
    align-items:center;
    padding:calc(6px * var(--scale));
    border-radius:calc(10px * var(--scale));
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 8px 26px rgba(0,0,0,0.12);
  }
  @media (max-width:520px){ .tertiary-actions{ width:100%; justify-content:center } }
  /* Multiplayer group (host/join) ‚Äî separate from other controls */
  .multiplayer-actions{
    display:flex;
    gap:calc(8px * var(--scale));
    align-items:center;
    padding:calc(6px * var(--scale));
    border-radius:calc(10px * var(--scale));
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 8px 26px rgba(0,0,0,0.12);
  }
  @media (max-width:520px){ .multiplayer-actions{ width:100%; justify-content:center } }
  /* separate group just for Rules / Credits to match themed boxes */
  .rules-actions{
    display:flex;
    gap:calc(8px * var(--scale));
    align-items:center;
    padding:calc(6px * var(--scale));
    border-radius:calc(10px * var(--scale));
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 8px 26px rgba(0,0,0,0.12);
  }
  @media (max-width:520px){ .rules-actions{ width:100%; justify-content:center } }
  button{
    padding:calc(8px * var(--scale)) calc(12px * var(--scale));
    border-radius:calc(8px * var(--scale));
    border:1px solid rgba(255,255,255,0.18); /* white border */
    background:rgba(255,255,255,0.06);
    color:#fff;
    cursor:pointer;
    font-size:calc(13px * var(--scale));
    font-weight:700; /* bold button text */
    transition: background 120ms ease, box-shadow 140ms ease, transform 120ms ease;
  }
  button:hover{ background: rgba(255,255,255,0.10); box-shadow: 0 6px 18px rgba(0,0,0,0.18); }
  button:focus{ outline: none; box-shadow: 0 0 0 3px rgba(255,255,255,0.06); }
  button:disabled{ opacity:.45; cursor:not-allowed; filter: grayscale(0.2); }

  /* Toggle button styling: match the other buttons exactly for color/appearance */
  .toggle-btn{ padding-left: calc(12px * var(--scale)); padding-right: calc(12px * var(--scale)); display:inline-flex; align-items:center; gap:8px; 
    /* match base button colors */
    background: rgba(255,255,255,0.06); color: #fff; border: 1px solid rgba(255,255,255,0.18);
  }
  .toggle-btn.toggle-on, .toggle-btn.toggle-off { /* keep visual identical to other buttons */ background: rgba(255,255,255,0.06); color:#fff; border:1px solid rgba(255,255,255,0.18); }

  /* Allow visual overflow for tile shadows, specular streaks and particle effects
    so bottom tiles aren't clipped. Add a little bottom padding to provide breathing room. */
  #boardWrap{display:flex;justify-content:center;width:100%;position:relative;overflow:visible;padding-bottom:calc(8px * var(--scale));}
  #board{display:grid;grid-template-columns:repeat(5,var(--tile));grid-gap:calc(6px * var(--scale));margin:0 auto;position:relative;z-index:3}
  .cell{
    width:var(--tile);
    height:var(--tile);
    display:flex;align-items:center;justify-content:center;
    border-radius:calc(8px * var(--scale));
    cursor:pointer;
    /* subtle outer edge and inner bevel for embossed look */
    box-shadow: 0 calc(6px * var(--scale)) calc(14px * var(--scale)) rgba(0,0,0,0.12),
                inset 0 calc(-6px * var(--scale)) calc(12px * var(--scale)) rgba(255,255,255,0.02),
                /* subtle gold rim (opaque) */
                0 0 0 var(--tile-gold-width) var(--tile-gold-edge);
    transition: transform 120ms ease, box-shadow 160ms ease;
    position:relative; overflow:visible;
  }

  .white{
    background: var(--tile-white-top);
    color:#111;
    border: 1px solid rgba(0,0,0,1);
    box-shadow: 0 calc(6px * var(--scale)) calc(14px * var(--scale)) rgba(0,0,0,0.08),
                inset 0 6px 12px rgba(255,255,255,0.7),
                inset 0 -6px 10px rgba(0,0,0,0.04),
                /* green edge (opaque) */
                0 0 0 var(--tile-gold-width) var(--tile-gold-edge);
  }

  .black{
    background: var(--tile-black-top);
    color:#fff;
    border: 1px solid rgba(255,255,255,1);
    box-shadow: 0 calc(6px * var(--scale)) calc(14px * var(--scale)) rgba(0,0,0,0.18),
                inset 0 6px 10px rgba(255,255,255,0.04),
                inset 0 -6px 12px rgba(0,0,0,0.45),
                /* green edge (opaque) */
                0 0 0 var(--tile-gold-width) var(--tile-gold-edge);
  }

  /* Hover/active states to emphasize shiny rim (green theme) */
  .cell:hover{
    /* do not change tile position on hover; only accentuate the rim */
    box-shadow: 0 calc(10px * var(--scale)) calc(28px * var(--scale)) rgba(0,0,0,0.18),
                inset 0 calc(-6px * var(--scale)) calc(12px * var(--scale)) rgba(255,255,255,0.02),
                0 0 0 calc(var(--tile-gold-width) * 1.6) var(--tile-gold-edge), /* stronger opaque rim */
                0 10px 36px var(--tile-gold-glow);
  }

  .cell:active{
    /* keep tile position stable on active press; boost rim */
    box-shadow: 0 calc(6px * var(--scale)) calc(14px * var(--scale)) rgba(0,0,0,0.14),
                inset 0 2px 8px rgba(0,0,0,0.06),
                0 0 0 calc(var(--tile-gold-width) * 1.2) var(--tile-gold-edge);
  }
  /* Tile specular streaks removed per user request */
  .captured-red{background:#ff6b6b}.captured-blue{background:#6bb2ff}
  .captured-red{background:#ff6b6b}.captured-blue{background:#6bb2ff}

  .pawn{
    position: relative;
    display: inline-flex;
    font-size: calc(36px * var(--scale));
    line-height: 1;
    width: calc(40px * var(--scale));
    height: calc(40px * var(--scale));
    align-items:center; justify-content:center;
    border-radius:50%;
    cursor:grab;
  }

  /* Multiplayer modal styles ‚Äî match other dark overlays (curved white border) */
  #multiplayerModal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9999; }
  #multiplayerModal.show{ display:flex; }
  /* Dark backdrop to match other overlays like the start/emoji pickers */
  #multiplayerModal .modal-backdrop{ position:absolute; inset:0; background:rgba(6,6,6,0.72); }
  /* Promotion overlay (matches other modal styles) */
  #promotionOverlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:10003; }
  #promotionOverlay.show{ display:flex; }
  #promotionOverlay .modal-backdrop{ position:absolute; inset:0; background:rgba(6,6,6,0.72); }
  #promotionOverlay .modal-box{ position:relative; z-index:2; width:min(420px, calc(92%)); background:#0b0b0b; color:#fff; border-radius:12px; border: 1px solid rgba(255,255,255,0.92); padding: 12px 16px; box-shadow:0 18px 46px rgba(0,0,0,0.32); text-align:center; }
  #promotionOverlay .modal-box h3{ margin:0 0 8px 0; font-size:16px; color:#fff; }
  #promotionOverlay .modal-box button{ background:#000; color:#fff; border:1px solid rgba(255,255,255,0.08); box-shadow:none; padding:10px 14px; border-radius:8px; font-weight:700; }
  /* Dark modal box styling to match other overlays (curved white border) */
  #multiplayerModal .modal-box{ position:relative; z-index:2; width:min(520px, calc(92%)); background:#0b0b0b; color:#fff; border-radius:14px; border: 1px solid rgba(255,255,255,0.92); padding: calc(14px * var(--scale)) calc(16px * var(--scale)); box-shadow:0 18px 46px rgba(0,0,0,0.32); text-align:center; }
  #multiplayerModal .modal-box h3{ margin:0 0 8px 0; font-size:18px; color:#fff; }
  #multiplayerModal .modal-close{ position:absolute; right:8px; top:6px; border-radius:6px; background:transparent; border:none; font-size:22px; padding:6px; cursor:pointer; color:#fff; }
  #multiplayerModal .modal-content{ display:flex; flex-direction:column; gap:12px; }
  #multiplayerModal input[type="text"]{ width:100%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.08); font-size:14px; background: rgba(255,255,255,0.02); color:#fff; }
  /* Invert colors for the Join Room paste field to make it stand out (light background, dark text) */
  #joinRoomInput{
    background: #ffffff !important;
    color: #111 !important;
    border: 1px solid rgba(0,0,0,0.12) !important;
  }
  #joinRoomInput::placeholder{ color: rgba(0,0,0,0.45); }
  #multiplayerModal .host-result{ display:flex; gap:8px; align-items:center; }
  #multiplayerModal code{ background:rgba(255,255,255,0.02); padding:6px 8px; border-radius:6px; font-family:monospace; color:#fff; }
  /* lighter info color on dark modal */
  #multiplayerModal .info{ font-size:13px; color:#ddd; }
  /* Buttons inside the modal should match other overlays (dark / prominent) */
  #multiplayerModal .modal-box button{ background:#000; color:#fff; border:1px solid rgba(255,255,255,0.08); box-shadow:none; padding:12px 18px; border-radius:8px; }
  /* Make Host and copy buttons pop with a white border */
  #modalCreateRoomBtn, #copyLobbyBtn {
    border: 2px solid rgba(255,255,255,0.96) !important;
    box-shadow: 0 10px 28px rgba(0,0,0,0.28);
    padding: 12px 20px;
    border-radius: 10px;
    background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    color: #fff;
  }

  /* Make the Join Room button in the modal visually prominent with a white border */
  #modalJoinRoomBtn {
    border: 2px solid rgba(255,255,255,0.96) !important;
    box-shadow: 0 10px 28px rgba(0,0,0,0.28);
    padding: 10px 18px;
    border-radius: 10px;
    background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    color: #fff;
  }

  /* Transient toast for copy feedback */
  /* Large centered Room ID overlay */
  .copy-toast{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%) scale(0.98);
    background: rgba(11,11,11,0.94);
    color:#fff;
    border:1px solid rgba(255,255,255,0.96);
    padding:18px 24px;
    border-radius:14px;
    opacity:0;
    pointer-events:none;
    transition: opacity 220ms ease, transform 220ms cubic-bezier(.2,.9,.2,1);
    z-index:10001;
    font-weight:800;
    font-size:18px;
    min-width:220px;
    text-align:center;
    box-shadow: 0 18px 46px rgba(0,0,0,0.36);
  }
  .copy-toast.show{ opacity:1; transform:translate(-50%,-50%) scale(1); pointer-events:auto }
  /* Hide the small status box under the Join Room input; we keep the element in DOM
    so existing JS that writes to it doesn't break, but it is visually removed. */
  #multiplayerStatus{ display:none !important; }
  /* Start mode overlay should visually match other modal boxes */
  #startModeOverlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9999; }
  #startModeOverlay.show{ display:flex; }
  /* Dark backdrop to match emoji picker and other overlays */
  #startModeOverlay .modal-backdrop{ position:absolute; inset:0; background:rgba(6,6,6,0.72); }
  /* Dark modal box styling to match other overlays like emoji picker */
  #startModeOverlay .modal-box{ position:relative; z-index:2; width:min(520px, calc(92%)); background:#0b0b0b; color:#fff; border-radius:14px; border: 1px solid rgba(255,255,255,0.92); padding: calc(14px * var(--scale)) calc(16px * var(--scale)); box-shadow:0 18px 46px rgba(0,0,0,0.32); text-align:center; }
  #startModeOverlay .modal-box h3{ margin:0 0 8px 0; font-size:18px; color:#fff; }
  #startModeOverlay .modal-box button{ background:#000; color:#fff; border:1px solid rgba(255,255,255,0.08); box-shadow:none; padding:12px 18px; border-radius:8px; font-weight:700; }
  #startModeOverlay .modal-box button.alt{ background:#18a058; border:none; }
  .pawn .pface { position: relative; z-index: 31; pointer-events: none; display: inline-block; line-height:1; }
  /* Pulsing neon ring shown for promoted pieces */
  .pawn .promoRing {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%) scale(1);
  /* even smaller so it sits inline with the small letter overlay */
  width: calc(44px * var(--scale));
  height: calc(44px * var(--scale));
    border-radius: 50%;
    z-index: 30; /* under promoGlyph (33) but above pface (31) */
    pointer-events: none;
  /* slight blur to smooth the glow while keeping it tight */
  filter: blur(0.8px);
    opacity: 0.0;
    transition: opacity 160ms ease, transform 160ms ease;
    box-shadow: 0 0 0 rgba(0,0,0,0);
    background: transparent;
    display: block;
    will-change: transform, opacity;
    animation: promoRingPulse 1200ms ease-in-out infinite;
  }
  .pawn .promoRing.red {
    /* brighter red neon with a tighter halo */
    background: radial-gradient(circle, rgba(255,120,120,0.20), rgba(255,80,80,0.08) 42%, transparent 58%);
  box-shadow: 0 0 22px rgba(255,95,95,0.98), 0 0 44px rgba(255,70,70,0.28), inset 0 0 6px rgba(255,140,140,0.12);
    opacity: 1.0;
    transform: translate(-50%, -50%) scale(1);
  }
  .pawn .promoRing.blue {
    /* brighter blue neon with a tighter halo */
    background: radial-gradient(circle, rgba(140,210,255,0.20), rgba(90,170,255,0.08) 42%, transparent 58%);
  box-shadow: 0 0 22px rgba(80,160,255,0.98), 0 0 44px rgba(40,120,220,0.30), inset 0 0 6px rgba(160,210,255,0.12);
    opacity: 1.0;
    transform: translate(-50%, -50%) scale(1);
  }
  @keyframes promoRingPulse {
    0% { transform: translate(-50%, -50%) scale(0.9); opacity: 0.6; }
    50% { transform: translate(-50%, -50%) scale(1.06); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(0.9); opacity: 0.6; }
  }
  /* (promoGlyph rules consolidated at the end of the stylesheet) */

  @keyframes pawnIdleSquashWiggle {
    0%   { transform: translateZ(0) translateX(0) rotate(0deg) scaleX(1)   scaleY(1); }
    12%  { transform: translateZ(0) translateX(-1px) rotate(-1.2deg) scaleX(1.03) scaleY(0.97); }
    25%  { transform: translateZ(0) translateX(1px)  rotate(1.1deg)  scaleX(1.04) scaleY(0.96); }
    37%  { transform: translateZ(0) translateX(-0.6px) rotate(-0.6deg) scaleX(1.01) scaleY(0.99); }
    50%  { transform: translateY(-3px) translateX(0) rotate(0deg)       scaleX(0.98) scaleY(1.04); }
    62%  { transform: translateZ(0) translateX(0.6px) rotate(0.6deg)   scaleX(1.02) scaleY(0.98); }
    75%  { transform: translateZ(0) translateX(-1px) rotate(-1deg)    scaleX(1.02) scaleY(0.98); }
    88%  { transform: translateZ(0) translateX(0.4px) rotate(0.5deg)   scaleX(1.01) scaleY(0.99); }
    100% { transform: translateZ(0) translateX(0) rotate(0deg)         scaleX(1)   scaleY(1); }
  }
  .pawn.idle { animation: pawnIdleSquashWiggle 2400ms cubic-bezier(.2,.7,.2,1) infinite; will-change: transform; }

  .pawn::before{
    content: "";
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%) scale(1);
    width: calc(52px * var(--scale));
    height: calc(52px * var(--scale));
    border-radius: 50%;
    z-index: 10; 
    opacity: 1;
    transition: opacity 100ms linear, transform 120ms ease, box-shadow 120ms ease;
    pointer-events: none;
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02);
    background: radial-gradient(circle at 50% 48%, rgba(255,255,255,0.98) 0%, rgba(255,120,120,0.98) 36%, rgba(255,80,80,0.75) 62%, rgba(255,60,60,0.45) 78%, rgba(255,60,60,0.12) 92%);
   /* Use normal blending so the pawn highlight remains visible on both
     light and dark tiles (avoids a brief disappearance when tiles
     change state during pointer interactions). */
   mix-blend-mode: normal;
    filter: saturate(1.25) contrast(1.2);
    animation: pawnHighlightPulse 1400ms ease-in-out infinite;
  }

  .pawn::after{
    content: "";
    position:absolute;
    left:50%;
    top:50%;
    transform: translate(-50%,-50%) scale(1);
    width: calc(72px * var(--scale));
    height: calc(72px * var(--scale));
    border-radius:50%;
    z-index: 8;
    opacity: 0.85;
    pointer-events:none;
    filter: blur(calc(6px * var(--scale))) saturate(1.25);
    background: radial-gradient(circle, rgba(255,120,120,0.75), transparent 42%);
  /* See note above: prefer normal blending to avoid flicker on white tiles. */
  mix-blend-mode: normal;
    transition: opacity 120ms ease, transform 120ms ease;
    animation: pawnGlowBreath 1600ms ease-in-out infinite;
  }

  .pawn[data-color="red"]::before{ background: radial-gradient(circle at 50% 48%, rgba(255,255,255,0.98) 0%, rgba(255,110,110,0.98) 36%, rgba(255,60,60,0.90) 62%, rgba(220,40,40,0.75) 78%, rgba(180,30,30,0.20) 92%); }
  .pawn[data-color="red"]::after{ background: radial-gradient(circle, rgba(255,90,90,0.92), transparent 42%); }
  .pawn[data-color="blue"]::before{ background: radial-gradient(circle at 50% 48%, rgba(255,255,255,0.98) 0%, rgba(140,200,255,0.98) 36%, rgba(80,150,255,0.90) 62%, rgba(40,120,255,0.75) 78%, rgba(20,90,200,0.20) 92%); }
  .pawn[data-color="blue"]::after{ background: radial-gradient(circle, rgba(100,170,255,0.92), transparent 42%); }

  .explosion { position: absolute; transform: translate(-50%, -50%); pointer-events: none; width: calc(260px * var(--scale)); height: calc(260px * var(--scale)); z-index: 18; }
  .explosion .ring { position: absolute; left:50%; top:50%; width:calc(40px * var(--scale)); height:calc(40px * var(--scale)); border-radius:50%; transform:translate(-50%,-50%) scale(0.3); border:calc(7px * var(--scale)) solid rgba(255,230,150,0.98); animation: ringPop 560ms cubic-bezier(.1,.9,.2,1) forwards; }
  @keyframes ringPop { to { transform: translate(-50%,-50%) scale(6.0); opacity: 0; } }
  .explosion .flash { position:absolute; left:50%; top:50%; width:calc(100px * var(--scale)); height:calc(100px * var(--scale)); transform:translate(-50%,-50%) scale(0.6); background: radial-gradient(circle at 50% 40%, rgba(255,255,255,0.98), rgba(255,220,120,0.95) 50%, transparent 70%); border-radius:50%; opacity:0.98; animation: flashPop 280ms cubic-bezier(.2,.9,.3,1) forwards; mix-blend-mode:screen; }
  @keyframes flashPop { to { transform: translate(-50%,-50%) scale(2.6); opacity:0; } }
  .explosion .shock { position:absolute; left:50%; top:50%; width:calc(160px * var(--scale)); height:calc(160px * var(--scale)); transform:translate(-50%,-50%) scale(0.2); border-radius:50%; background: radial-gradient(circle, rgba(255,240,160,0.12), rgba(255,160,60,0.06) 45%, transparent 60%); opacity:0.9; animation: shockPop 560ms cubic-bezier(.1,.9,.2,1) forwards; mix-blend-mode:screen; }
  @keyframes shockPop { to { transform: translate(-50%,-50%) scale(3.2); opacity: 0; } }
  .explosion .particle { position:absolute; left:50%; top:50%; width:calc(14px * var(--scale)); height:calc(14px * var(--scale)); border-radius:50%; opacity:1; transform-origin:center; animation: particleFly 760ms cubic-bezier(.12,.85,.28,1) forwards; box-shadow:0 calc(6px * var(--scale)) calc(18px * var(--scale)) rgba(0,0,0,0.32); background: radial-gradient(circle at 30% 30%, #fff, transparent 55%), #ffd26b; }
  @keyframes particleFly { to { transform: translate(var(--tx), var(--ty)) scale(0.36); opacity: 0; filter: blur(0.8px); } }
  /* Movement trails (larger, brighter, longer-lived) */
  .trail { position: absolute; pointer-events: none; width: calc(140px * var(--scale)); height: calc(64px * var(--scale)); transform: translate(-50%, -50%); border-radius: calc(20px * var(--scale)); z-index: 16; overflow: visible; }

  /* Fire trail ‚Äî bigger flames, longer rise */
  /* particles use a consistent base size so red and blue trails match visually */
  .trail { --trail-px: calc(18px * var(--scale)); --trail-w: calc(140px * var(--scale)); --trail-h: calc(64px * var(--scale)); }
  .trail { width: var(--trail-w); height: var(--trail-h); }
  /* apply base particle styling to both flame and spark elements */
  .trail .flame, .trail .spark { position: absolute; width: var(--trail-px); height: var(--trail-px); border-radius: 50%; transform: translate(-50%,-50%) scale(1); filter: blur(calc(1.6px * var(--scale))); mix-blend-mode: normal; opacity:0.98; }
  .trail-fire .flame:nth-child(1){ background: radial-gradient(circle at 40% 30%, rgba(255,240,180,1), rgba(255,140,60,0.98) 36%, rgba(230,80,40,0.94) 62%, rgba(200,40,30,0.85) 78%, transparent 92%); left:36%; top:66%; }
  .trail-fire .flame:nth-child(2){ background: radial-gradient(circle at 40% 30%, rgba(255,220,160,0.96), rgba(255,120,40,0.94) 36%, rgba(220,60,30,0.86) 58%, transparent 90%); left:64%; top:56%; }
  .trail-fire .flame:nth-child(3){ background: radial-gradient(circle at 40% 30%, rgba(255,200,140,0.94), rgba(255,110,40,0.92) 36%, rgba(210,60,30,0.84) 58%, transparent 90%); left:50%; top:60%; }
  .trail-fire .flame{ animation: trailFireRise 1600ms cubic-bezier(.2,.8,.2,1) forwards; }
  .trail-fire .flame:nth-child(4){ background: radial-gradient(circle at 40% 30%, rgba(255,230,150,0.94), rgba(255,130,50,0.9) 36%, rgba(220,70,40,0.82) 58%, transparent 90%); left:58%; top:68%; animation-delay:160ms; }
  @keyframes trailFireRise { to { transform: translate(-50%,-220%) scale(0.5); opacity: 0; } }

  /* Sparkle trail ‚Äî stronger glow, longer life, particles match red size */
  /* spark-specific coloring and positions handled per nth-child below */
  .trail-sparkle .spark:nth-child(1){ background: radial-gradient(circle at 40% 30%, rgba(255,255,255,1) 0%, rgba(150,220,255,0.98) 30%, rgba(70,170,255,0.94) 56%, rgba(30,120,220,0.86) 78%, rgba(20,90,180,0.6) 92%); left:50%; top:50%; box-shadow: 0 0 calc(12px * var(--scale)) rgba(80,170,255,0.44), 0 0 calc(4px * var(--scale)) rgba(255,255,255,0.65); }
  .trail-sparkle .spark:nth-child(2){ background: radial-gradient(circle at 40% 30%, rgba(255,255,255,0.98), rgba(160,230,255,0.96) 30%, rgba(100,190,255,0.92) 58%, rgba(40,140,220,0.8) 82%); left:72%; top:42%; }
  .trail-sparkle .spark:nth-child(3){ background: radial-gradient(circle at 40% 30%, rgba(255,255,255,0.96), rgba(140,210,255,0.95) 30%, rgba(80,170,255,0.9) 58%, rgba(30,120,220,0.76) 82%); left:38%; top:58%; }
  .trail-sparkle .spark{ animation: trailSparkle 1400ms cubic-bezier(.2,.8,.2,1) forwards; }
  .trail-sparkle .spark:nth-child(4){ background: radial-gradient(circle at 40% 30%, rgba(255,255,255,0.96), rgba(160,225,255,0.96) 30%, rgba(90,180,255,0.92) 58%, rgba(40,140,220,0.8) 82%); left:58%; top:38%; animation-delay:160ms; }
  @keyframes trailSparkle { to { transform: translate(-50%,-90%) scale(0.4); opacity: 0; } }

  #status{min-height:20px;font-size:calc(14px * var(--scale));text-align:center}
  .small{font-size:calc(12px * var(--scale));opacity:0.9;text-align:center}

  .flower-field { position: fixed; inset: 0; pointer-events: none; overflow: hidden; z-index: 0; }
  .flower { position: absolute; opacity: var(--opa,0.22); transform-origin: center; will-change: transform, opacity; animation: flowerFloat var(--dur) linear infinite; user-select: none; font-family: serif; }
  @keyframes flowerFloat { 0% { transform: translateY(0) rotate(0deg) scale(var(--scaleF,1)); opacity: var(--opa,0.22); } 50% { transform: translateY(-8px) rotate(var(--rot,0deg)) scale(calc(var(--scaleF,1) * 1.03)); opacity: calc(var(--opa,0.22) + 0.06); } 100% { transform: translateY(0) rotate(calc(var(--rot,0deg) * -1)) scale(var(--scaleF,1)); opacity: var(--opa,0.22); } }
  /* When paused (tab hidden or modal open) stop flower animations to save CPU */
  .flower-field.paused .flower { animation-play-state: paused !important; opacity: 0.18; }

  @media (max-width:520px){
    :root{--scale:1; --tile:48px}
    h1{font-size:18px}
    .panel-backdrop{padding:10px}
    button{padding:7px 10px}
  }

  @media (prefers-reduced-motion: reduce){
    .pawn.idle { animation: none; transform: none; }
    .pawn::before, .pawn::after, .pawn:hover::before, .pawn:hover::after { animation: none; transition: none; filter: none; mix-blend-mode: normal; }
  }

  /* When in single-player mode hide the Host/Join group (they're multiplayer-only) */
  body.single-player .multiplayer-actions { display: none !important; }

  /* Victory overlay */
  .victory-overlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(6,6,6,0.6); z-index:9999; opacity:0; pointer-events:none; transition:opacity 220ms ease; }
  .victory-overlay.show{ opacity:1; pointer-events:auto; }
  .victory-card{ background:linear-gradient(180deg,#111 0%, #1b1b1b 100%); color:#fff; padding:calc(22px * var(--scale)); border-radius:12px; box-shadow:0 18px 60px rgba(0,0,0,0.6); text-align:center; width: min(640px, calc(92%)); }
  .victory-card h2{ margin:0 0 calc(8px * var(--scale)) 0; font-size:calc(22px * var(--scale)); }
  .victory-card p{ margin:0 0 calc(14px * var(--scale)) 0; font-size:calc(16px * var(--scale)); opacity:0.95 }
  .victory-actions{ display:flex; gap:calc(10px * var(--scale)); justify-content:center; margin-top:calc(12px * var(--scale)); }
  .victory-emoji{ font-size:calc(54px * var(--scale)); margin-bottom:calc(6px * var(--scale)); display:block }
  /* Splash screen overlay (uses local splash.png by default or window.SPLASH_IMAGE_URL)
     Place the provided image next to this HTML as `splash.png` or set
     `window.SPLASH_IMAGE_URL` before this script to override. */
  /* splash overlay: fade to black over 900ms; initial background is white and will transition to black when hiding */
  #splashOverlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:10002; background:#fff; transition: opacity 1400ms ease, background-color 1400ms ease, visibility 1400ms; opacity:1; pointer-events:auto; }
  #splashOverlay.hide{ opacity:0; background-color:#000; pointer-events:none; visibility:hidden; }
  /* remove drop shadow per request; keep mild rounding for the image */
  #splashOverlay img{ max-width:78vw; max-height:78vh; width:auto; height:auto; object-fit:contain; border-radius:6px; }
  /* Ensure image and button can fade independently of the overlay so we
    can keep a solid black overlay while the contents fade (prevents
    underlying UI from showing through during the transition). */
  #splashOverlay img, #splashOverlay .start-btn { transition: opacity 1400ms ease, transform 300ms ease; }
  /* fade state applied to the wrapper when hiding: only the contents fade
    while the overlay background becomes black instantly. */
  #splashOverlay .start-wrap.fade-out img,
  #splashOverlay .start-wrap.fade-out .start-btn {
   opacity: 0;
   transform: translateY(6px) scale(0.995);
  }
  /* Start button inside splash overlay */
  #splashOverlay .start-btn{
    margin-top:0; display:inline-flex; align-items:center; justify-content:center; gap:10px;
    padding:14px 120px; font-weight:900; font-size:40px; border-radius:18px; cursor:pointer; letter-spacing:0.6px;
    background:#000000; color:#ffffff; border:4px solid #000000; box-shadow: none; transition: transform 140ms ease, opacity 140ms ease, background-color 140ms ease, color 140ms ease;
  }
  /* hover: slightly lighter black to indicate interactivity */
  #splashOverlay .start-btn:hover{ background:#111111; color:#ffffff; }
  #splashOverlay .start-btn:active{ transform: translateY(1px) scale(0.995); }
  /* position the start button below the image while keeping overlay centered */
  #splashOverlay .start-wrap{ display:flex; flex-direction:column; align-items:center; gap:0; }
  /* Responsive: scale the Play button down on small viewports so it doesn't crowd the image */
  @media (max-width:520px){
    #splashOverlay .start-btn{ padding:18px 28px; font-size:20px; border-radius:12px; }
  }
  /* Consolidated .promoGlyph rules: single authoritative placement + styling
     Placed at the end of the stylesheet to override any earlier/accidental rules. */
  body .app #board .cell .promoGlyph {
    position: absolute !important;
    /* moved closer to the tile corner */
    top: calc(2px * var(--scale)) !important;
    right: calc(2px * var(--scale)) !important;
    left: auto !important;
    transform: none !important;
    z-index: 33 !important;
    pointer-events: none !important;
  /* widen the badge so a larger crown can sit to the left of the letter */
  width: calc(36px * var(--scale)) !important;
  height: calc(22px * var(--scale)) !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  font-size: calc(14px * var(--scale)) !important;
    font-weight: 800 !important;
    line-height: 1 !important;
    border-radius: 50% !important;
    background: transparent !important;
    color: inherit !important;
    text-shadow: -1px -1px 0 rgba(0,0,0,0.7), 1px -1px 0 rgba(0,0,0,0.7), -1px 1px 0 rgba(0,0,0,0.7), 1px 1px 0 rgba(0,0,0,0.7), 0 0 8px rgba(0,0,0,0.12) !important;
    box-shadow: none !important;
    transition: transform 160ms cubic-bezier(.2,.9,.2,1), background-color 160ms ease, box-shadow 160ms ease !important;
  }
  /* Ensure promoted state rules don't recenter the badge */
  /* promoted-state (pawn is sibling of the badge) */
  body .app #board .cell .pawn.promoted-knight ~ .promoGlyph,
  body .app #board .cell .pawn.promoted-bishop ~ .promoGlyph {
    transform: none !important;
  }
  /* Team color variants */
  body .app #board .cell .pawn.promoted-bishop[data-color="red"] ~ .promoGlyph,
  body .app #board .cell .pawn.promoted-knight[data-color="red"] ~ .promoGlyph {
    background: transparent !important;
    color: #ff6b6b !important;
    box-shadow: none !important;
    text-shadow: -1px -1px 0 rgba(0,0,0,0.7), 1px -1px 0 rgba(0,0,0,0.7), -1px 1px 0 rgba(0,0,0,0.7), 1px 1px 0 rgba(0,0,0,0.7), 0 0 10px rgba(255,90,90,0.85) !important;
  }
  body .app #board .cell .pawn.promoted-bishop[data-color="blue"] ~ .promoGlyph,
  body .app #board .cell .pawn.promoted-knight[data-color="blue"] ~ .promoGlyph {
    background: transparent !important;
    color: #58b0ff !important;
    box-shadow: none !important;
    text-shadow: -1px -1px 0 rgba(0,0,0,0.7), 1px -1px 0 rgba(0,0,0,0.7), -1px 1px 0 rgba(0,0,0,0.7), 1px 1px 0 rgba(0,0,0,0.7), 0 0 10px rgba(80,160,255,0.85) !important;
  }
  /* small crown placed next to the B/K glyph; sized slightly smaller so it reads as a badge */
  body .app #board .cell .promoGlyph .promoCrown {
    /* place crown left of the letter, larger and slightly raised */
    margin-right: calc(6px * var(--scale));
    font-size: calc(18px * var(--scale));
    line-height: 1;
    display: inline-block;
    transform: translateY(-2px);
    pointer-events: none;
  }
  /* nudge the B/K left a bit so spacing looks tighter next to the crown */
  body .app #board .cell .promoGlyph .promoLetter {
    display: inline-block;
    transform: translateX(calc(-3px * var(--scale))) translateY(0);
    font-size: calc(14px * var(--scale));
    line-height: 1;
    font-weight: 800;
    pointer-events: none;
  }
</style>
</head>
<body>
  <div class="flower-field" id="flowerField" aria-hidden="true"></div>

  <div class="app" role="application" aria-label="Attack-Tac-Toe">
    <div class="panel-backdrop">
      <header>
        <div class="titleRow">
          <h1>Kings Plane</h1>
          <div class="vbadge">v006.9</div>
        </div>
        <div id="status" class="small" aria-live="polite"></div>
      </header>

      <div id="boardWrap"><div id="board" role="grid" aria-label="game board"></div></div>
  <div id="controls" style="margin-top:calc(8px * var(--scale));display:flex;gap:12px;flex-wrap:wrap;justify-content:center;align-items:center">
        <div class="primary-actions" aria-hidden="false">
          <button id="newBtn">New</button>
          <button id="resetBtn">Reset</button>
        </div>
        <div class="secondary-actions" aria-hidden="false">
          <button id="undoBtn" disabled>Undo</button>
          <button id="redoBtn" disabled>Redo</button>
        </div>
        <div class="tertiary-actions" aria-hidden="false">
          <button id="aiToggleBtn">Play vs AI</button>
          <button id="themeBtn">Theme</button>
          <button id="emojiBtn" title="Choose emoji (Multiplayer)">Emoji</button>
        </div>
        <div class="multiplayer-actions" aria-hidden="false">
          <button id="hostRoomBtn">Host</button>
          <button id="joinRoomBtn">Join</button>
        </div>
        <div class="rules-actions" aria-hidden="false">
          <button id="rulesBtn">Rules</button>
          <button id="creditsBtn">Credits</button>
        </div>
      </div>
    </div>
  </div>
  <div id="victoryOverlay" class="victory-overlay" aria-hidden="true">
    <div class="victory-card" role="dialog" aria-modal="true">
      <span id="victoryEmoji" class="victory-emoji">üèÜ</span>
      <h2 id="victoryTitle">Victory!</h2>
      <p id="victoryText">Player wins the game.</p>
        <div id="rematchStatus" class="small" style="margin-top:8px;min-height:18px"></div>
      <div class="victory-actions">
        <button id="victoryRestart">Play Again</button>
        <button id="victoryClose">Close</button>
      </div>
    </div>
  </div>
    <!-- Firebase Realtime Database (modular) helper. This module imports the
         modular SDK and exposes a small wrapper on window.__pe_firebase_mod so
         the rest of the non-module game script can continue to call helpers
         without converting the whole script to an ES module. -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-analytics.js";
      import {
        getDatabase,
        ref as fbRef,
        push as fbPush,
        set as fbSet,
        onValue as fbOnValue,
        runTransaction as fbRunTransaction,
        update as fbUpdate
      } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

      // Lightweight wrapper so the existing non-module helpers can use the
      // modular SDK without additional refactor.
      window.__pe_firebase_mod = {
        _initialized: false,
        init(config){
          if(this._initialized) return;
          try{
            this.app = initializeApp(config);
            // initialize Realtime Database handle
            // Allow an override from the page (useful for testing incorrect config)
            const dbUrl = window.__FIREBASE_DB_URL_OVERRIDE || (config && config.databaseURL) || null;
            if(dbUrl){
              this.db = getDatabase(this.app, dbUrl);
              this.dbUrl = dbUrl;
            }else{
              this.db = getDatabase(this.app);
              this.dbUrl = null;
            }
            // initialize Analytics if a measurementId is present (guarded)
            try{
              if(config && config.measurementId){
                this.analytics = getAnalytics(this.app);
                console.log('Firebase Analytics initialized');
              }
            }catch(e){ console.warn('Firebase analytics init failed', e); }
            this._initialized = true;
            console.log('Firebase (modular) initialized');
          }catch(e){ console.warn('Firebase init error (modular)', e); throw e; }
        },
        ref(pathOrRef){
          if(typeof pathOrRef === 'string') return fbRef(this.db, pathOrRef);
          return pathOrRef;
        },
        push(pathOrRef){
          const r = (typeof pathOrRef === 'string') ? this.ref(pathOrRef) : pathOrRef;
          return fbPush(r);
        },
        set(pathOrRef, val){
          const r = (typeof pathOrRef === 'string') ? this.ref(pathOrRef) : pathOrRef;
          return fbSet(r, val);
        },
        runTransaction(pathOrRef, updater){
          const r = (typeof pathOrRef === 'string') ? this.ref(pathOrRef) : pathOrRef;
          return fbRunTransaction(r, updater);
        },
        onValue(pathOrRef, cb){
          const r = (typeof pathOrRef === 'string') ? this.ref(pathOrRef) : pathOrRef;
          // onValue returns an unsubscribe function in the modular SDK
          return fbOnValue(r, cb);
        },
        update(pathOrRef, val){
          const r = (typeof pathOrRef === 'string') ? this.ref(pathOrRef) : pathOrRef;
          return fbUpdate(r, val);
        }
      };
    </script>
    <script>
      // Firebase configuration (inserted by assistant from user-provided snippet)
      // For compatibility with the existing compat-based helpers in this file
      // we keep the config on window.__FIREBASE_CONFIG so initFirebaseFromWindowConfig
      // can use it without further refactor. If you prefer ESM imports, I can
      // refactor the helpers to use modular SDK methods instead.
      window.__FIREBASE_CONFIG = {
        apiKey: "AIzaSyAPkwoQng2ko0yCxbI-wBJ6T1BSepNEgJQ",
        authDomain: "attack-tac-toe.firebaseapp.com",
        // Correct Realtime Database URL (updated)
        databaseURL: "https://attack-tac-toe-default-rtdb.firebaseio.com/",
        projectId: "attack-tac-toe",
        storageBucket: "attack-tac-toe.firebasestorage.app",
        messagingSenderId: "266634464313",
        appId: "1:266634464313:web:7b3fe340096d246436d1e8",
        measurementId: "G-ECL1XBNXRW"
      };
    </script>

  <script>
/* Project Elmo 004.7 ‚Äî full script with swipe, chain rules, double-step first move */

// DOM refs
const board = document.getElementById('board');
const boardWrap = document.getElementById('boardWrap');
const status = document.getElementById('status');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
// Container for undo/redo button group ‚Äî used to hide the whole group during multiplayer
const secondaryActions = document.querySelector('.secondary-actions');

// Multiplayer modal DOM and wiring (replaces alert-based Host/Join UX)
const multiplayerModal = document.createElement('div');
multiplayerModal.id = 'multiplayerModal';
multiplayerModal.setAttribute('aria-hidden', 'true');
multiplayerModal.innerHTML = `
  <div class="modal-backdrop"></div>
  <div class="modal-box" role="dialog" aria-modal="true">
  <button class="modal-close" id="multiplayerClose">√ó</button>
    <h3>Online Play</h3>
    <div class="modal-content">
      <div class="host-section">
        <div style="display:flex;gap:8px;align-items:center;flex-direction:column;">
          <div style="display:flex;gap:8px;align-items:center;">
                <button id="modalCreateRoomBtn">Click here to Host a match.</button>
          </div>
          <div style="display:flex;gap:12px;align-items:center;margin-top:8px;" class="host-color-choice">
            <span class="info">Host plays as:</span>
            <label style="display:inline-flex;align-items:center;gap:6px;"><input type="radio" name="hostColor" value="red" checked> Red</label>
            <label style="display:inline-flex;align-items:center;gap:6px;"><input type="radio" name="hostColor" value="blue"> Blue</label>
          </div>
        </div>
        
        <!-- created room id and copy button removed -->
      </div>
      <div class="join-section" style="display:flex;flex-direction:column;align-items:center;gap:12px;">
        <input id="joinRoomInput" type="text" placeholder="Paste room id to join" style="width:80%;max-width:420px;" />
        <button id="modalJoinRoomBtn">Join Room</button>
        <div id="multiplayerStatus" class="info" style="text-align:center;margin-top:6px;min-height:18px;width:80%;max-width:420px;"></div>
      </div>
      <!-- Lobby section removed per user request (Create Lobby / Refresh) -->
      <!-- Removed inline red Close button per user request. Use the top-right √ó to close. -->
    </div>
  </div>
`;
document.body.appendChild(multiplayerModal);
// small transient toast used to notify host that room id was copied
const multiplayerToast = document.createElement('div');
multiplayerToast.id = 'multiplayerToast';
multiplayerToast.className = 'copy-toast';
multiplayerToast.setAttribute('aria-hidden','true');
document.body.appendChild(multiplayerToast);

function showCopiedToast(msg='Copied to clipboard'){
  try{
    if(!multiplayerToast) return;
    multiplayerToast.textContent = msg;
    multiplayerToast.setAttribute('aria-hidden','false');
    multiplayerToast.classList.add('show');
    // hide after 1.6s
    setTimeout(()=>{ try{ multiplayerToast.classList.remove('show'); multiplayerToast.setAttribute('aria-hidden','true'); }catch(e){} }, 1600);
  }catch(e){ console.warn('showCopiedToast err', e); }
}

// Wait until the multiplayerToast has finished showing (no overlapping toasts)
function waitForToastToFinish(timeoutMs = 3000){
  return new Promise(resolve => {
    try{
      if(!multiplayerToast) return resolve();
      // If not currently shown, resolve immediately
      if(!multiplayerToast.classList.contains('show')) return resolve();
      const start = Date.now();
      const t = setInterval(()=>{
        if(!multiplayerToast.classList.contains('show')){
          clearInterval(t); return resolve();
        }
        if(Date.now() - start > timeoutMs){ clearInterval(t); return resolve(); }
      }, 80);
    }catch(e){ resolve(); }
  });
}

// Show emoji picker after active toast(s) finish. If preferredSide is provided
// ("red" or "blue") the picker will be constrained so the user only edits
// that side's emoji (useful when hosting a lobby before a room exists).
function showEmojiPickerAfterToasts(preferredSide = null){
  return (async ()=>{
    try{ await waitForToastToFinish(3000); }catch(e){}
    try{
      // If preferredSide is provided and the picker exists, pre-configure UI
      try{
        if(typeof preferredSide === 'string' && preferredSide){
          window.humanColor = preferredSide;
          refreshSideSelectionUI();
          // hide the side chooser and disable the opposite team's options
          const sideChooser = document.querySelector('.side-chooser'); if(sideChooser) sideChooser.style.display = 'none';
          const redChooser = document.getElementById('emojiOptionsRed');
          const blueChooser = document.getElementById('emojiOptionsBlue');
          const teamNameRed = document.getElementById('teamNameRed');
          const teamNameBlue = document.getElementById('teamNameBlue');
          if(preferredSide === 'red'){
            if(teamNameBlue) teamNameBlue.style.display = 'none';
            if(blueChooser && blueChooser.parentElement) blueChooser.parentElement.style.display = 'none';
            try{ if(emojiPickerOverlay) emojiPickerOverlay.classList.add('multiplayer'); }catch(e){}
            if(teamNameRed) teamNameRed.style.display = '';
            if(redChooser && redChooser.parentElement) redChooser.parentElement.style.display = '';
            if(redChooser) Array.from(redChooser.children).forEach(b=>{ b.style.pointerEvents = 'auto'; b.style.opacity = ''; });
          } else {
            if(teamNameRed) teamNameRed.style.display = 'none';
            if(redChooser && redChooser.parentElement) redChooser.parentElement.style.display = 'none';
            try{ if(emojiPickerOverlay) emojiPickerOverlay.classList.add('multiplayer'); }catch(e){}
            if(teamNameBlue) teamNameBlue.style.display = '';
            if(blueChooser && blueChooser.parentElement) blueChooser.parentElement.style.display = '';
            if(blueChooser) Array.from(blueChooser.children).forEach(b=>{ b.style.pointerEvents = 'auto'; b.style.opacity = ''; });
          }
        } else {
          // No preferred side: ensure picker reflects multiplayer restrictions
          try{ adjustEmojiPickerForMultiplayer(); }catch(e){}
        }
      }catch(e){ console.warn('showEmojiPickerAfterToasts: pre-config err', e); }
      // show the picker
      if(emojiPickerOverlay){ emojiPickerOverlay.setAttribute('aria-hidden','false'); emojiPickerOverlay.style.display = 'flex'; }
      // ensure selection UI is correct
      try{ refreshEmojiSelectionUI(); }catch(e){}
    }catch(e){ console.warn('showEmojiPickerAfterToasts err', e); }
  })();
}

// Startup mode chooser overlay (Single Player vs Multiplayer)
const startModeOverlay = document.createElement('div');
startModeOverlay.id = 'startModeOverlay';
startModeOverlay.setAttribute('aria-hidden','true');
startModeOverlay.innerHTML = `
  <div class="modal-backdrop"></div>
  <div class="modal-box" role="dialog" aria-modal="true">
    <h3>Choose Mode</h3>
    <div style="margin-top:12px; display:flex; gap:12px; justify-content:center;">
      <button id="startSingleBtn">Single Player</button>
      <button id="startMultiBtn" class="alt">Multiplayer</button>
    </div>
    <div style="margin-top:10px;font-size:13px;color:#333;">Choose Single Player to play vs AI or Multiplayer to play online.</div>
  </div>
`;
document.body.appendChild(startModeOverlay);

// Splash overlay: show the provided branding image at startup.
(function(){
  try{
    if(document.getElementById('splashOverlay')) return;
    const splash = document.createElement('div');
    splash.id = 'splashOverlay';
    splash.setAttribute('aria-hidden','false');
    const img = document.createElement('img');
    img.alt = 'Kings Plane';
    // allow a page script to override the image URL by setting window.SPLASH_IMAGE_URL
    img.src = (typeof window.SPLASH_IMAGE_URL === 'string' && window.SPLASH_IMAGE_URL) ? window.SPLASH_IMAGE_URL : 'splash.png';
  // wrap image and start button so they layout vertically
  const startWrap = document.createElement('div'); startWrap.className = 'start-wrap';
  startWrap.appendChild(img);
  const startBtn = document.createElement('button');
  startBtn.className = 'start-btn'; startBtn.type = 'button'; startBtn.textContent = 'Play'; startBtn.setAttribute('aria-label','Play game');
  // Match splash logo font if provided, otherwise use a serif stack similar to the logo
  try{ startBtn.style.fontFamily = (typeof window.SPLASH_FONT_FAMILY === 'string' && window.SPLASH_FONT_FAMILY) ? window.SPLASH_FONT_FAMILY : "'Playfair Display', Georgia, 'Times New Roman', serif"; }catch(e){}
  // clicking the Start button should hide the splash and open the Start Mode overlay
  startBtn.addEventListener('click', (ev)=>{ try{ ev.stopPropagation();
      // Start intro music (if any) ‚Äî this is a user gesture so audio autoplay is allowed
      try{ playIntroIfAvailable(); }catch(e){ console.warn('playIntro err', e); }
      hide(); try{ showStartModeOverlay(); }catch(e){} }catch(e){} });
  startWrap.appendChild(startBtn);
    splash.appendChild(startWrap);
    document.body.appendChild(splash);
  const hide = ()=>{ try{
      // Fade out image and button only while keeping the overlay opaque.
      // This prevents the image's white background from appearing against
      // a black overlay during the transition.
      try{ startWrap.classList.add('fade-out'); }catch(e){}
      splash.setAttribute('aria-hidden','true');
      // After the content fade completes (900ms), switch the overlay to
      // black quickly and then remove the element after a small buffer.
      setTimeout(()=>{
        try{
          // Make backgroundColor change immediate to avoid a visible cross-fade
          const prev = splash.style.transition;
          try{ splash.style.transition = 'background-color 0ms ease, visibility 0ms'; }catch(e){}
          splash.style.backgroundColor = '#000';
          // restore previous transition so remaining splash rules behave normally
          try{ splash.style.transition = prev || ''; }catch(e){}
        }catch(e){}
        setTimeout(()=>{ try{ if(splash && splash.parentElement) splash.parentElement.removeChild(splash); }catch(e){} }, 120);
      }, 1420);
    }catch(e){} };
    // Only close the splash when the Start button is pressed. Disabled auto-hide and background click-to-dismiss.
  }catch(e){ console.warn('splash init err', e); }
})();

  // --- Intro music player --------------------------------------------------
  // Plays a MIDI/audio URL if window.START_MIDI_URL is set; otherwise uses a
  // simple WebAudio synth fallback to play a short intro melody. The Play
  // button click is used to trigger playback so it meets browser gesture
  // requirements.
  let _introAudioEl = null;
  let _introSynthNodes = [];
  let _introPlaying = false;
  function stopIntro(){
    try{
      if(_introAudioEl){ try{ _introAudioEl.pause(); _introAudioEl.src = ''; _introAudioEl.remove(); }catch(e){} _introAudioEl = null; }
      if(_introSynthNodes && _introSynthNodes.length){ _introSynthNodes.forEach(n=>{ try{ n.osc.stop(0); n.gain.disconnect(); }catch(e){} }); _introSynthNodes = []; }
    }catch(e){ console.warn('stopIntro err', e); }
    _introPlaying = false;
  }

  function playAudioUrl(url){
    return new Promise((resolve,reject)=>{
      try{
        stopIntro();
        const a = document.createElement('audio');
        a.src = url;
        a.preload = 'auto';
        a.autoplay = true;
        a.volume = (typeof window.START_MUSIC_VOLUME === 'number') ? clamp(window.START_MUSIC_VOLUME, 0, 1) : 0.7;
        a.addEventListener('ended', ()=>{ _introPlaying = false; resolve(); });
        a.addEventListener('canplay', ()=>{ try{ a.play().catch(()=>{}); }catch(e){} });
        a.addEventListener('error', (e)=>{ reject(new Error('audio failed')); });
        document.body.appendChild(a);
        _introAudioEl = a;
        _introPlaying = true;
        // resolve once playback begins (best-effort)
        resolve();
      }catch(e){ reject(e); }
    });
  }

  function freqFromMidi(m){ return 440 * Math.pow(2, (m - 69)/12); }

  function playSynthIntro(){
    try{
      stopIntro();
      ensureAudioContext();
      if(!audioCtx) return;
      _introPlaying = true;
      const gainMaster = audioCtx.createGain(); gainMaster.gain.value = 0.14; gainMaster.connect(audioCtx.destination);
      // Simple arpeggiated intro (MIDI note numbers) as fallback
      const seq = [64,67,71,76,71,67,64,59, 64,67,71,76,79,76,71,67];
      const durations = 200; // ms per note
      let t0 = audioCtx.currentTime + 0.02;
      seq.forEach((midi,i)=>{
        const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freqFromMidi(midi), t0 + (i * durations)/1000);
        g.gain.setValueAtTime(0.0001, t0 + (i * durations)/1000);
        g.gain.linearRampToValueAtTime(1.0 * 0.12, t0 + (i * durations)/1000 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + ((i+1) * durations)/1000 - 0.02);
        osc.connect(g); g.connect(gainMaster);
        osc.start(t0 + (i * durations)/1000); osc.stop(t0 + ((i+1) * durations)/1000);
        _introSynthNodes.push({ osc, gain: g });
      });
      // auto-clear after sequence
      setTimeout(()=>{ stopIntro(); }, seq.length * durations + 160);
    }catch(e){ console.warn('playSynthIntro err', e); }
  }

  function playIntroIfAvailable(){
    try{
      if(_introPlaying) return; // already playing
      // If a URL is provided, attempt to play it via audio element first
      if(typeof window.START_MIDI_URL === 'string' && window.START_MIDI_URL.trim()){
        playAudioUrl(window.START_MIDI_URL).catch(err=>{ console.warn('failed to play START_MIDI_URL, falling back to synth', err); playSynthIntro(); });
        return;
      }
      // No URL: play fallback synth intro
      playSynthIntro();
    }catch(e){ console.warn('playIntroIfAvailable err', e); }
  }


const startSingleBtn = document.getElementById('startSingleBtn');
const startMultiBtn = document.getElementById('startMultiBtn');
function showStartModeOverlay(){
  startModeOverlay.classList.add('show');
  startModeOverlay.setAttribute('aria-hidden','false');
  try{ if(typeof emojiPickerOverlay !== 'undefined' && emojiPickerOverlay){ emojiPickerOverlay.setAttribute('aria-hidden','true'); emojiPickerOverlay.style.display = 'none'; } }catch(e){}
}
function hideStartModeOverlay(){ startModeOverlay.classList.remove('show'); startModeOverlay.setAttribute('aria-hidden','true'); }

startSingleBtn && startSingleBtn.addEventListener('click', ()=>{
  try{ hideStartModeOverlay();
    // mark page as single-player so multiplayer UI (host/join) hides
    try{ document.body.classList.add('single-player'); }catch(e){}
    // enable AI by default in single-player and update toggle UI
    try{
  aiEnabled = true;
  // default to Hard difficulty for single-player
  aiDifficulty = 'hard';
  const btn = document.getElementById('aiToggleBtn');
  if(btn){ btn.setAttribute('aria-pressed','true'); btn.textContent = 'AI: Hard'; btn.classList.add('toggle-on'); btn.classList.remove('toggle-off'); }
      try{ scheduleAiIfNeeded(320); }catch(e){}
    }catch(e){}
    // Open emoji picker for single player setup
    if(emojiPickerOverlay){
      // Ensure the picker reflects multiplayer state (if any) before showing
      try{ adjustEmojiPickerForMultiplayer(); }catch(e){}
      emojiPickerOverlay.setAttribute('aria-hidden','false'); emojiPickerOverlay.style.display = 'flex';
    }
  }catch(e){ console.warn('startSingle err', e); }
});

startMultiBtn && startMultiBtn.addEventListener('click', ()=>{
  try{ hideStartModeOverlay(); showMultiplayerModal(); }catch(e){ console.warn('startMulti err', e); }
});

const multiplayerClose = document.getElementById('multiplayerClose');
const modalCloseBtn = document.getElementById('modalCloseBtn');
const modalCreateRoomBtn = document.getElementById('modalCreateRoomBtn');
const modalJoinRoomBtn = document.getElementById('modalJoinRoomBtn');
const joinRoomInput = document.getElementById('joinRoomInput');
const multiplayerStatus = document.getElementById('multiplayerStatus');
const modalCreateLobbyBtn = document.getElementById('modalCreateLobbyBtn');
const modalRefreshLobbiesBtn = document.getElementById('modalRefreshLobbiesBtn');
const lobbiesList = document.getElementById('lobbiesList');
const lobbyPlayers = document.getElementById('lobbyPlayers');
const createdLobbyContainer = document.getElementById('createdLobby');
const createdLobbyId = document.getElementById('createdLobbyId');
const copyLobbyBtn = document.getElementById('copyLobbyBtn');
const startMatchBtn = document.getElementById('startMatchBtn');

// Ensure Host/copy buttons have consistent label
try{ if(modalCreateRoomBtn) modalCreateRoomBtn.textContent = 'Click here to Host a match.'; }catch(e){}
try{ if(copyLobbyBtn) copyLobbyBtn.textContent = 'Click here to Host a match.'; }catch(e){}

function showMultiplayerModal(){
  multiplayerModal.classList.add('show'); multiplayerModal.setAttribute('aria-hidden','false');
  try{ document.body.classList.remove('single-player'); }catch(e){}
  // disable AI when entering multiplayer and update toggle UI
  try{
    aiEnabled = false;
    if(_aiTimer){ clearTimeout(_aiTimer); _aiTimer = null; }
    const btn = document.getElementById('aiToggleBtn');
    if(btn){ btn.setAttribute('aria-pressed','false'); btn.textContent = 'AI: Off'; btn.classList.remove('toggle-on'); btn.classList.add('toggle-off'); }
  }catch(e){}
}
function hideMultiplayerModal(){ multiplayerModal.classList.remove('show'); multiplayerModal.setAttribute('aria-hidden','true'); try{ if(createdLobbyContainer) createdLobbyContainer.style.display='none'; }catch(e){} multiplayerStatus.textContent=''; }

// wire top-level Host/Join buttons to open modal
const hostRoomBtn = document.getElementById('hostRoomBtn');
const joinRoomBtn = document.getElementById('joinRoomBtn');
if(hostRoomBtn) hostRoomBtn.addEventListener('click', ()=>{ showMultiplayerModal(); });
if(joinRoomBtn) joinRoomBtn.addEventListener('click', ()=>{ showMultiplayerModal(); joinRoomInput.focus(); });

// Emoji button in the top controls: open multiplayer emoji picker (constrained to player's side)
const emojiBtn = document.getElementById('emojiBtn');
if(emojiBtn){
  emojiBtn.addEventListener('click', ()=>{
    try{
      const preferred = (multiplayerRoomId && myPlayerColor) ? myPlayerColor : (window.humanColor || 'red');
      showEmojiPickerAfterToasts(preferred);
    }catch(e){ console.warn('emojiBtn click err', e); }
  });
}

multiplayerClose && multiplayerClose.addEventListener('click', hideMultiplayerModal);
modalCloseBtn && modalCloseBtn.addEventListener('click', hideMultiplayerModal);

// copyRoomBtn removed (no created room UI). copyLobbyBtn remains for lobbies.
copyLobbyBtn && copyLobbyBtn.addEventListener('click', ()=>{
  try{ navigator.clipboard.writeText(createdLobbyId.textContent || '').then(()=>{ multiplayerStatus.textContent = 'Lobby copied!'; setTimeout(()=> multiplayerStatus.textContent = '', 1500); }); }catch(e){ /* ignore */ }
});

startMatchBtn && startMatchBtn.addEventListener('click', ()=>{
  try{
    const lid = createdLobbyId && createdLobbyId.textContent ? createdLobbyId.textContent.trim() : null;
    if(!lid){ multiplayerStatus.textContent = 'No lobby id'; return; }
    multiplayerStatus.textContent = 'Starting match...';
    // call existing helper to start match from lobby
    startMatchFromLobby(lid);
  }catch(e){ console.warn('startMatch click err', e); multiplayerStatus.textContent = 'Failed to start'; }
});

// Diagnostic: test a small write/read to the DB to confirm connectivity
// Test connection helper removed (button removed from UI)

// Room diagnostic: quick snapshot/write/read to help debug room sync issues
// Room diagnostic helper removed (button removed from UI)

// Debug checkbox removed from the UI. Developers can still toggle the
// bypass at runtime via the console when needed:
//   window.__pe_bypassUpdatedBy = true
// The listener wiring and DOM checkbox were removed to keep the UI clean.

function fetchAndShowRoomState(){
  try{
    initFirebaseFromWindowConfig();
    if(!firebaseDb) { multiplayerStatus.textContent = 'Firebase not configured'; console.warn('fetchRoomState: firebase not configured'); return; }
    if(!multiplayerRoomId){ multiplayerStatus.textContent = 'No room joined'; console.warn('fetchRoomState: multiplayerRoomId not set'); return; }
    const path = 'rooms/' + multiplayerRoomId + '/state';
    multiplayerStatus.textContent = 'Reading room state...';
    const unsub = window.__pe_firebase_mod.onValue(path, snap=>{
      try{
        const v = snap.val();
        console.log('fetchAndShowRoomState:', path, v);
        multiplayerStatus.textContent = 'Room state read (console)';
      }catch(e){ console.warn('fetchRoomState onValue err', e); multiplayerStatus.textContent = 'Read error'; }
      try{ if(unsub) unsub(); }catch(e){}
    });
  }catch(e){ console.warn('fetchAndShowRoomState err', e); multiplayerStatus.textContent = 'Error'; }
}

// Refresh Room State button removed from UI; fetchAndShowRoomState remains available via console if needed.

// Lobby listener unsubscribe
let _lobbiesListenerUnsub = null;

function renderLobbiesList(snapshotVal){
  lobbiesList.innerHTML = '';
  if(!snapshotVal) return lobbiesList.innerHTML = '<div class="info">No lobbies</div>';
  const keys = Object.keys(snapshotVal).sort((a,b)=> (snapshotVal[b].createdAt||0)-(snapshotVal[a].createdAt||0));
  keys.forEach(k=>{
    const item = snapshotVal[k];
    const div = document.createElement('div');
    div.style.display = 'flex'; div.style.justifyContent = 'space-between'; div.style.alignItems='center'; div.style.padding='6px 4px';
    const info = document.createElement('div');
    info.innerHTML = `<strong>${item.status||'waiting'}</strong> &nbsp; Host: ${item.players && item.players.host ? item.players.host : '‚Äî'} &nbsp; Color:${item.players && item.players.hostColor ? item.players.hostColor : (item.hostColor||'red')}`;
    const actions = document.createElement('div');
    const joinBtn = document.createElement('button'); joinBtn.textContent = 'Join'; joinBtn.style.fontSize='12px';
    joinBtn.addEventListener('click', ()=>{ joinLobby(k); });
    const spectateBtn = document.createElement('button'); spectateBtn.textContent='View'; spectateBtn.style.fontSize='12px'; spectateBtn.addEventListener('click', ()=>{ listenLobby(k); });
    actions.appendChild(joinBtn); actions.appendChild(spectateBtn);
    div.appendChild(info); div.appendChild(actions);
    lobbiesList.appendChild(div);
  });
}

function listLobbies(){
  if(!firebaseDb) initFirebaseFromWindowConfig();
  if(!firebaseDb) { multiplayerStatus.textContent='Not configured'; return; }
  // remove previous listener
  try{ if(_lobbiesListenerUnsub){ _lobbiesListenerUnsub(); _lobbiesListenerUnsub = null; } }catch(e){}
  _lobbiesListenerUnsub = window.__pe_firebase_mod.onValue('lobbies', snap=>{
    const v = snap.val();
    renderLobbiesList(v);
  });
}

function stopListingLobbies(){ try{ if(_lobbiesListenerUnsub){ _lobbiesListenerUnsub(); _lobbiesListenerUnsub = null; } }catch(e){} }

modalCreateRoomBtn && modalCreateRoomBtn.addEventListener('click', async ()=>{
  multiplayerStatus.textContent = 'Creating...';
  // capture current board state as initial snapshot
  const snap = (typeof takeSnapshot === 'function') ? takeSnapshot() : {};
  // read host color choice
  let hostColor = 'red';
  try{ const sel = document.querySelector('input[name="hostColor"]:checked'); if(sel && sel.value) hostColor = sel.value; }catch(e){}
  try{
    const roomId = await createRoom(snap, hostColor);
    // Paste the created room id into the join input and copy it to clipboard for easy sharing
    try{ if(joinRoomInput) joinRoomInput.value = roomId || multiplayerRoomId || ''; }catch(e){}
    try{ if(navigator && navigator.clipboard && roomId){ await navigator.clipboard.writeText(roomId); } }catch(e){ /* ignore clipboard errors */ }
    // Hide the Host Online modal first, then show the copied notification after the modal is gone
    try{ hideMultiplayerModal(); }catch(e){}
    // wait for modal hide transition/animation to finish (give a little buffer)
    await new Promise(resolve => setTimeout(resolve, 360));
    try{ showCopiedToast('Room ID copied to clipboard'); }catch(e){}
    // After the copied toast finishes, open the emoji picker for the host's side
    try{ await showEmojiPickerAfterToasts(myPlayerColor); }catch(e){}
    multiplayerStatus.textContent = 'Room created (id copied)';
    // createRoom already sets multiplayerRoomId and starts listening
  }catch(e){ multiplayerStatus.textContent = 'Create failed'; console.warn(e); }
});

modalCreateLobbyBtn && modalCreateLobbyBtn.addEventListener('click', ()=>{
  multiplayerStatus.textContent = 'Creating lobby...';
  const snap = (typeof takeSnapshot === 'function') ? takeSnapshot() : {};
  let hostColor = 'red';
  try{ const sel = document.querySelector('input[name="hostColor"]:checked'); if(sel && sel.value) hostColor = sel.value; }catch(e){}
  createLobby(snap, hostColor).then(lobbyId=>{
    multiplayerStatus.textContent = 'Lobby created';
    // auto-show players
    listenLobby(lobbyId);
    try{
      if(createdLobbyContainer){ createdLobbyContainer.style.display = 'flex'; }
      if(createdLobbyId){ createdLobbyId.textContent = lobbyId; }
      // After creating a lobby, show the emoji picker (constrain to host color)
      try{ showEmojiPickerAfterToasts(hostColor); }catch(e){}
    }catch(e){}
  }).catch(e=>{ multiplayerStatus.textContent = 'Create lobby failed'; console.warn(e); });
});

modalRefreshLobbiesBtn && modalRefreshLobbiesBtn.addEventListener('click', ()=>{ listLobbies(); });

modalJoinRoomBtn && modalJoinRoomBtn.addEventListener('click', async ()=>{
  const id = (joinRoomInput.value || '').trim();
  if(!id){ multiplayerStatus.textContent = 'Enter a room id'; return; }
  multiplayerStatus.textContent = 'Joining...';
  try{
    const roomId = await joinRoom(id);
    multiplayerStatus.textContent = 'Joined';
    // Hide the multiplayer modal first, then show the centered toast after it finishes hiding
    try{ hideMultiplayerModal(); }catch(e){}
    await new Promise(resolve => setTimeout(resolve, 360));
    try{ showCopiedToast('Joined room: ' + (roomId || id)); }catch(e){}
    // After the joined toast finishes, open the emoji picker for the local player's side
    try{ await showEmojiPickerAfterToasts(myPlayerColor); }catch(e){}
  }catch(e){ multiplayerStatus.textContent = 'Join failed'; console.warn(e); }
});

// --- Firebase Realtime Database multiplayer helpers ---
let firebaseApp = null;
let firebaseDb = null;
let multiplayerRoomId = null;
let _roomListenerUnsubscribe = null;
// persistent meta/rematch listeners for the current room
let _roomMetaUnsub = null;
let _roomRematchUnsub = null;
let lastRoomMeta = null; // holds last seen room object (players, hostColor, etc.)
// rematch state tracking
let _myRematchRequested = false;
let _lastRematchObj = null;
// persistent client id base (shared across tabs) and a per-tab session id so
// different browser tabs/windows still produce different client identifiers.
const __pe_base_client_id = localStorage.getItem('__pe_client_id') || ('pe_' + Math.random().toString(36).slice(2,9));
localStorage.setItem('__pe_client_id', __pe_base_client_id);
const __pe_session_id = sessionStorage.getItem('__pe_session_id') || ('s_' + Math.random().toString(36).slice(2,9));
sessionStorage.setItem('__pe_session_id', __pe_session_id);
// myClientId combines the base persistent id and the per-tab session id so
// two tabs in the same browser produce different ids (useful for testing).
let myClientId = __pe_base_client_id + '|' + __pe_session_id;
console.log('multiplayer: myClientId=', myClientId);

// Which color this client controls when in a multiplayer room (null for spectator)
let myPlayerColor = null;

function initFirebaseFromWindowConfig(){
  try{
    if(window.__FIREBASE_CONFIG && window.__pe_firebase_mod && !firebaseApp){
      // initialize the modular SDK wrapper (module script placed earlier)
      window.__pe_firebase_mod.init(window.__FIREBASE_CONFIG);
      firebaseApp = window.__pe_firebase_mod.app;
      firebaseDb = window.__pe_firebase_mod.db;
      console.log('Firebase initialized (modular Realtime DB)');
    }
  }catch(e){ console.warn('Firebase init error', e); }
}

// Read room metadata once and set myPlayerColor for this client (host/guest mapping)
function fetchAndSetPlayerColor(roomId){
  try{
    if(!firebaseDb) initFirebaseFromWindowConfig();
    if(!firebaseDb) return;
    const roomPath = 'rooms/' + roomId;
    const unsub = window.__pe_firebase_mod.onValue(roomPath, snap=>{
      try{
        const v = snap.val();
        if(v){
          const players = v.players || {};
          const hostId = players.host;
          const guestId = players.guest;
          const hostColor = v.hostColor || (v.state && v.state.currentPlayer) || 'red';
          if(hostId === myClientId) myPlayerColor = hostColor;
          else if(guestId === myClientId) myPlayerColor = (hostColor === 'red' ? 'blue' : 'red');
          else myPlayerColor = null;
          console.log('fetchAndSetPlayerColor: myPlayerColor=', myPlayerColor);
          try{ updateUndoRedoButtons(); }catch(e){}
        }
      }catch(e){ console.warn('fetchAndSetPlayerColor err', e); }
      try{ if(unsub) unsub(); }catch(e){}
    });
  }catch(e){ console.warn('fetchAndSetPlayerColor top err', e); }
}

async function createRoom(initialSnapshot, hostColor = 'red'){
  // Create room with a friendly human-readable id (e.g. "brave-otter-314").
  // We attempt to atomically create rooms/<id> via a transaction to avoid
  // clobbering an existing id; if many collisions occur we fall back to
  // the original push() behavior.
  if(!firebaseDb) initFirebaseFromWindowConfig();
  if(!firebaseDb) { alert('Firebase not configured. Paste your config into window.__FIREBASE_CONFIG'); return Promise.reject(new Error('Firebase not configured')); }
  try{
    const payloadBase = {
      createdAt: Date.now(),
      players: { host: myClientId },
      hostColor: hostColor,
      status: 'playing',
      // initial state stored at rooms/<id>/state for simpler sync
      state: Object.assign({}, initialSnapshot, { currentPlayer: hostColor, _meta: { updatedBy: myClientId, ts: Date.now() } })
    };

    // small friendly id generator
    function makeFriendlyId(){
      const ADJ = ['brave','quick','merry','bright','calm','bold','jolly','clever','gentle','happy','lucky','mystic','sly','fuzzy','rusty','sleepy','spry','shiny','wise','zesty'];
      const NOUN = ['otter','panda','fox','tiger','raven','beetle','badger','owl','dolphin','sparrow','hare','koala','penguin','ferret','heron','walrus','goblin','sprite','capybara','walnut'];
      const a = ADJ[Math.floor(Math.random()*ADJ.length)];
      const b = NOUN[Math.floor(Math.random()*NOUN.length)];
      const num = Math.floor(Math.random()*900) + 100; // 100-999
      return `${a}-${b}-${num}`;
    }

    // attempt to create a room with a friendly id using a transaction; retry if it already exists
    const MAX_ATTEMPTS = 8;
    for(let attempt=0; attempt<MAX_ATTEMPTS; attempt++){
      const candidateId = makeFriendlyId();
      try{
        const txnRes = await window.__pe_firebase_mod.runTransaction('rooms/' + candidateId, cur => {
          if(cur) return; // already exists, abort by returning undefined
          return payloadBase;
        });
        // If the SDK returns an object with committed flag, check it
        if(txnRes && typeof txnRes === 'object' && typeof txnRes.committed !== 'undefined'){
          if(txnRes.committed){
            multiplayerRoomId = candidateId;
            myPlayerColor = hostColor;
            listenRoom(candidateId);
            try{ updateUndoRedoButtons(); }catch(e){}
            console.log('createRoom: created (friendly)', candidateId, 'myPlayerColor=', myPlayerColor);
            return candidateId;
          } else {
            // not committed (someone else created it) -> retry
            continue;
          }
        }
        // Some SDK variants return the new value directly when successful
        // Treat any truthy response as success
        if(txnRes){
          multiplayerRoomId = candidateId;
          myPlayerColor = hostColor;
          listenRoom(candidateId);
          try{ updateUndoRedoButtons(); }catch(e){}
          console.log('createRoom: created (friendly - alt result)', candidateId, 'myPlayerColor=', myPlayerColor);
          return candidateId;
        }
      }catch(e){
        console.warn('createRoom: friendly id txn attempt failed', e);
        // continue to next attempt
      }
    }

    // Fallback: if friendly id attempts failed, use original push() to guarantee creation
    try{
      const roomsRef = window.__pe_firebase_mod.ref('rooms');
      const newRoomRef = window.__pe_firebase_mod.push(roomsRef);
      const roomId = newRoomRef.key;
      await window.__pe_firebase_mod.set(newRoomRef, payloadBase);
      multiplayerRoomId = roomId;
      myPlayerColor = hostColor;
      listenRoom(roomId);
      try{ updateUndoRedoButtons(); }catch(e){}
      console.log('createRoom: created (fallback push)', roomId, 'myPlayerColor=', myPlayerColor);
      return roomId;
    }catch(e){ console.warn('createRoom fallback push failed', e); throw e; }
  }catch(e){ console.warn('createRoom error', e); return Promise.reject(e); }
}

function joinRoom(roomId){
  // Simplified join: try to add guest via transaction; then listen to state
  if(!firebaseDb) initFirebaseFromWindowConfig();
  if(!firebaseDb) { alert('Firebase not configured. Paste your config into window.__FIREBASE_CONFIG'); return Promise.reject(new Error('Firebase not configured')); }
  try{
    const playersPath = 'rooms/' + roomId + '/players';
    return window.__pe_firebase_mod.runTransaction(playersPath, players=>{
      if(!players) return { guest: myClientId };
      if(!players.guest) players.guest = myClientId;
      return players;
    }).then(result=>{
      // Some SDK variants return { committed, snapshot } or the new value directly
      // Treat result as success if no explicit committed:false
      if(result && typeof result === 'object' && typeof result.committed !== 'undefined' && !result.committed){
        throw new Error('Failed to join room (maybe full)');
      }
      multiplayerRoomId = roomId;
        listenRoom(roomId);
        // Fetch room info to determine which color this client controls
        try{ fetchAndSetPlayerColor(roomId); }catch(e){ console.warn('fetchAndSetPlayerColor err', e); }
  try{ updateUndoRedoButtons(); }catch(e){}
      console.log('joinRoom: joined', roomId);
      return roomId;
    }).catch(err=>{ console.warn('joinRoom txn err', err); throw err; });
  }catch(e){ console.warn('joinRoom error', e); return Promise.reject(e); }
}

function listenRoom(roomId){
  if(!firebaseDb) return;
  // remove previous listener
  try{ if(_roomListenerUnsubscribe){ _roomListenerUnsubscribe(); _roomListenerUnsubscribe = null; } }catch(e){ /* ignore */ }
  const statePath = 'rooms/' + roomId + '/state';
  // Listen only to the /state child for a simple, reliable sync model
  _roomListenerUnsubscribe = window.__pe_firebase_mod.onValue(statePath, snap => {
  const state = snap.val();
  console.log('multiplayer: state update on', statePath, state);
  if(!state) return;
    try{
      // By default ignore updates authored by this client to avoid
      // re-applying our own writes. For debugging, a bypass flag can be
      // toggled (window.__pe_bypassUpdatedBy === true) to force applying
      // remote snapshots even when updatedBy matches.
      if(!(window.__pe_bypassUpdatedBy === true)){
        if(state._meta && state._meta.updatedBy === myClientId){
          console.log('multiplayer: ignoring own update (updatedBy matches myClientId)');
          return;
        }
      } else {
        console.log('multiplayer: bypassing updatedBy ignore (debug)');
      }
    }catch(e){ console.warn('multiplayer: error checking updatedBy', e); }
    try{
      if(state.board || typeof state.currentPlayer === 'string'){
        applySnapshot(state);
        // If the remote snapshot marks gameOver, show the end overlay (victory/defeat)
        try{
          if(state.gameOver && typeof state.winner === 'string'){
            showEndOverlay(state.winner);
          }
        }catch(e){ console.warn('listenRoom: showEndOverlay failed', e); }
      } else {
        console.warn('multiplayer: remote state missing expected fields', state);
      }
    }catch(e){ console.warn('failed apply remote snapshot', e); }
  });
  // also fetch room metadata (players/hostColor) so we know which color this client controls
  try{
    const roomPath = 'rooms/' + roomId;
    // keep a persistent metadata listener so we always know the players and hostColor
    try{ if(_roomMetaUnsub){ _roomMetaUnsub(); _roomMetaUnsub = null; } }catch(e){}
    _roomMetaUnsub = window.__pe_firebase_mod.onValue(roomPath, snap=>{
      try{
        const v = snap.val();
        lastRoomMeta = v || null;
        if(v){
          const players = v.players || {};
          const hostId = players.host;
          const guestId = players.guest;
          const hostColor = v.hostColor || (v.state && v.state.currentPlayer) || 'red';
          if(hostId === myClientId) myPlayerColor = hostColor;
          else if(guestId === myClientId) myPlayerColor = (hostColor === 'red' ? 'blue' : 'red');
          else myPlayerColor = null;
          // If the room meta includes selected emoji or names, apply them locally
          try{
            if(v.selectedEmoji && typeof v.selectedEmoji === 'object'){
              window.selectedEmoji = Object.assign({}, window.selectedEmoji || {}, v.selectedEmoji);
            }
            if(v.selectedEmojiNames && typeof v.selectedEmojiNames === 'object'){
              window.selectedEmojiNames = Object.assign({}, window.selectedEmojiNames || {}, v.selectedEmojiNames);
            }
            // Refresh UI and pawn faces to reflect any remote changes
            try{ refreshEmojiSelectionUI(); }catch(e){}
            try{ updateStatus(); }catch(e){}
            try{ document.querySelectorAll('.pawn .pface').forEach(pf=>{ const pawnEl = pf.parentElement; if(pawnEl && pawnEl.dataset && pawnEl.dataset.color){ pf.textContent = pawnEl.dataset.color === 'red' ? window.selectedEmoji.red : window.selectedEmoji.blue; } }); }catch(e){}
            // Ensure the picker UI reflects multiplayer mode if needed
            try{ adjustEmojiPickerForMultiplayer(); }catch(e){}
          }catch(e){ console.warn('apply remote selectedEmoji err', e); }
          console.log('multiplayer: set myPlayerColor=', myPlayerColor);
          try{ updateUndoRedoButtons(); }catch(e){}
        }
      }catch(e){ console.warn('room metadata onValue err', e); }
    });
    // Also listen for rematch requests under rooms/<id>/rematch
    try{ if(_roomRematchUnsub){ _roomRematchUnsub(); _roomRematchUnsub = null; } }catch(e){}
    const rematchPath = 'rooms/' + roomId + '/rematch';
    _roomRematchUnsub = window.__pe_firebase_mod.onValue(rematchPath, snap=>{
      try{ handleRematchUpdate(snap.val()); }catch(e){ console.warn('rematch onValue handler failed', e); }
    });
  }catch(e){ console.warn('listenRoom: failed to read room metadata', e); }
}

function sendSnapshotToRoom(snapshot){
  if(!firebaseDb || !multiplayerRoomId) return;
  const statePath = 'rooms/' + multiplayerRoomId + '/state';
  const payload = Object.assign({}, snapshot, { _meta: { updatedBy: myClientId, ts: Date.now() } });
  console.log('sendSnapshotToRoom: writing to', statePath, 'updatedBy=', myClientId, 'ts=', payload._meta.ts);
  try{
    return window.__pe_firebase_mod.set(statePath, payload).then(()=>{
      console.log('multiplayer: sent snapshot to room', multiplayerRoomId, payload._meta && payload._meta.ts);
    }).catch(e=>{ console.warn('sendSnapshot error', e); throw e; });
  }catch(e){ console.warn('sendSnapshot error', e); return Promise.reject(e); }
}

// Rematch helpers: send a rematch request and clear rematch state
function sendRematchRequest(){
  if(!firebaseDb || !multiplayerRoomId) return;
  try{
    const rematchPath = 'rooms/' + multiplayerRoomId + '/rematch';
    const payload = {};
    payload[myClientId] = { ts: Date.now() };
    _myRematchRequested = true;
    console.log('rematch: sending request for', myClientId);
    return window.__pe_firebase_mod.update(rematchPath, payload).catch(e=>{ console.warn('sendRematchRequest failed', e); });
  }catch(e){ console.warn('sendRematchRequest err', e); }
}

function clearRematchRequests(){
  if(!firebaseDb || !multiplayerRoomId) return;
  try{
    const rematchPath = 'rooms/' + multiplayerRoomId + '/rematch';
    return window.__pe_firebase_mod.set(rematchPath, null).catch(e=>{ console.warn('clearRematchRequests failed', e); });
  }catch(e){ console.warn('clearRematchRequests err', e); }
}

function withdrawMyRematchRequest(){
  if(!firebaseDb || !multiplayerRoomId) return;
  try{
    const rematchPath = 'rooms/' + multiplayerRoomId + '/rematch';
    const payload = {}; payload[myClientId] = null;
    return window.__pe_firebase_mod.update(rematchPath, payload).catch(e=>{ console.warn('withdrawMyRematchRequest failed', e); });
  }catch(e){ console.warn('withdrawMyRematchRequest err', e); }
}

// Called whenever the rematch node under the room changes
function handleRematchUpdate(rematchObj){
  _lastRematchObj = rematchObj || {};
  // If overlay is open, update its rematch status UI
  try{
    const remEl = document.getElementById('rematchStatus');
    const restart = document.getElementById('victoryRestart');
    if(!remEl) return;
    // Determine players
    const players = (lastRoomMeta && lastRoomMeta.players) ? lastRoomMeta.players : {};
    const hostId = players.host || null;
    const guestId = players.guest || null;
    const hostAgreed = !!(rematchObj && hostId && rematchObj[hostId]);
    const guestAgreed = !!(rematchObj && guestId && rematchObj[guestId]);
    // update rematch status copy
    if(_myRematchRequested){
      remEl.textContent = 'You requested a rematch. ' + ((hostAgreed && guestAgreed) ? 'Both players agreed.' : 'Waiting for opponent...');
      if(restart){ restart.disabled = true; restart.textContent = (hostAgreed && guestAgreed) ? 'Starting...' : 'Waiting...'; }
      try{ const resetB = document.getElementById('resetBtn'); if(resetB){ resetB.disabled = true; resetB.textContent = (hostAgreed && guestAgreed) ? 'Starting...' : 'Waiting...'; } }catch(e){}
    } else if(hostAgreed || guestAgreed){
      // opponent requested (or host) but we haven't clicked yet
      remEl.textContent = 'Opponent requested a rematch. Click Rematch to agree.';
      if(restart){ restart.disabled = false; restart.textContent = 'Rematch'; }
      try{ const resetB = document.getElementById('resetBtn'); if(resetB){ resetB.disabled = false; resetB.textContent = 'Rematch'; } }catch(e){}
    } else {
      remEl.textContent = '';
      if(restart){ restart.disabled = false; restart.textContent = 'Rematch'; }
      try{ const resetB = document.getElementById('resetBtn'); if(resetB){ resetB.disabled = false; resetB.textContent = 'Reset'; } }catch(e){}
    }

    // If both players agreed, perform authoritative reset (one client will write)
    if(hostAgreed && guestAgreed){
      // reset local flag
      _myRematchRequested = false;
      // perform reset by sending cleared snapshot to room and clearing rematch node
      try{
        console.log('rematch: both players agreed; sending reset snapshot');
        resetBoard();
        const snap = takeSnapshot(); snap.gameOver = false; snap.winner = null;
        sendSnapshotToRoom(snap).then(()=>{
          // clear rematch requests after successful reset
          clearRematchRequests().catch(e=>{});
          // hide victory/defeat overlay for a clean rematch start
          try{
            const overlay = document.getElementById('victoryOverlay');
            if(overlay){ overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); }
            try{ board.style.pointerEvents = ''; }catch(e){}
            try{ stopVictoryTune(); }catch(e){}
            const remEl = document.getElementById('rematchStatus'); if(remEl) remEl.textContent = '';
            const restartBtn = document.getElementById('victoryRestart'); if(restartBtn){ restartBtn.disabled = false; restartBtn.textContent = 'Rematch'; }
            try{ const resetB = document.getElementById('resetBtn'); if(resetB){ resetB.disabled = false; resetB.textContent = 'Reset'; } }catch(e){}
          }catch(e){ console.warn('rematch: failed to hide overlay', e); }
        }).catch(e=>{ console.warn('rematch: failed to send reset snapshot', e); });
      }catch(e){ console.warn('rematch handling reset err', e); }
    }
  }catch(e){ console.warn('handleRematchUpdate err', e); }
}

// ------------------
// Lobby-based multiplayer helpers
// ------------------
function createLobby(initialSnapshot, hostColor = 'red'){
  if(!firebaseDb) initFirebaseFromWindowConfig();
  if(!firebaseDb) { return Promise.reject(new Error('Firebase not configured')); }
  try{
    const lobbiesRef = window.__pe_firebase_mod.ref('lobbies');
    const newRef = window.__pe_firebase_mod.push(lobbiesRef);
    const lobbyId = newRef.key;
    const payload = {
      createdAt: Date.now(),
      host: myClientId,
      hostColor: hostColor,
      players: { host: myClientId },
      status: 'waiting',
      state: Object.assign({}, initialSnapshot, { currentPlayer: hostColor, _meta: { updatedBy: myClientId, ts: Date.now() } })
    };
    return window.__pe_firebase_mod.set(newRef, payload).then(()=>{
      console.log('lobby created', lobbyId);
      return lobbyId;
    });
  }catch(e){ console.warn('createLobby error', e); return Promise.reject(e); }
}

let _currentLobbyListener = null;
function listenLobby(lobbyId){
  if(!firebaseDb) initFirebaseFromWindowConfig();
  if(!firebaseDb) return;
  // cleanup previous
  try{ if(_currentLobbyListener){ _currentLobbyListener(); _currentLobbyListener = null; } }catch(e){}
  const lobbyPath = 'lobbies/' + lobbyId;
  _currentLobbyListener = window.__pe_firebase_mod.onValue(lobbyPath, snap=>{
    const data = snap.val();
    console.log('multiplayer.lobby update', lobbyId, data);
    if(!data) return;
    // render players list
    try{
      lobbyPlayers.style.display = 'block';
      lobbyPlayers.innerHTML = `<div><strong>Lobby:</strong> ${lobbyId} &nbsp; Status: ${data.status||'waiting'}</div>`;
      // reflect lobby id in createdLobby UI so host/guest can see it
      try{ if(createdLobbyContainer){ createdLobbyContainer.style.display = 'flex'; } if(createdLobbyId){ createdLobbyId.textContent = lobbyId; } }catch(e){}
      // Show start button only for the host and when lobby is waiting
      try{ if(startMatchBtn){ if(data.host && data.host === myClientId && data.status !== 'started'){ startMatchBtn.style.display = 'inline-block'; startMatchBtn.disabled = false; } else { startMatchBtn.style.display = 'none'; startMatchBtn.disabled = true; } } }catch(e){}
      const ul = document.createElement('div');
      ul.style.marginTop='8px';
      for(const k in (data.players||{})){
        const pid = data.players[k];
        const line = document.createElement('div');
        line.textContent = `${k}: ${pid}` + (pid === myClientId ? ' (you)' : '');
        ul.appendChild(line);
      }
      lobbyPlayers.appendChild(ul);
      // if lobby started, auto-join the created room
      if(data.status === 'started' && data.roomId){
        console.log('multiplayer: lobby started, joining room', data.roomId);
        multiplayerStatus.textContent = 'Match started ‚Äî joining room...';
        // join the room and stop listening to lobby
        joinRoom(data.roomId).then(rid=>{
          multiplayerStatus.textContent = 'Joined room';
          hideMultiplayerModal();
        }).catch(err=>{ console.warn('failed joinRoom from lobby', err); multiplayerStatus.textContent = 'Failed to join room'; });
      }
    }catch(e){ console.warn('render lobby players failed', e); }
  });
}

function joinLobby(lobbyId){
  if(!firebaseDb) initFirebaseFromWindowConfig();
  if(!firebaseDb) { return Promise.reject(new Error('Firebase not configured')); }
  const playersPath = 'lobbies/' + lobbyId + '/players';
  return window.__pe_firebase_mod.runTransaction(playersPath, players=>{
    if(!players) return { guest: myClientId };
    if(!players.guest) players.guest = myClientId;
    return players;
  }).then(res=>{
    console.log('joined lobby txn', res);
    listenLobby(lobbyId);
    return lobbyId;
  }).catch(e=>{ console.warn('joinLobby err', e); throw e; });
}

function startMatchFromLobby(lobbyId){
  // only host can start
  const lobbyRef = window.__pe_firebase_mod.ref('lobbies/' + lobbyId);
  // read once then create room
  // Use onValue once via the modular onValue and immediately unsubscribe
  const unsub = window.__pe_firebase_mod.onValue(lobbyRef, snap=>{
    const lobby = snap.val();
    try{ if(unsub) unsub(); }catch(e){}
    if(!lobby) return;
    if(lobby.host !== myClientId){ alert('Only the host can start the match'); return; }
    // create a room from the lobby.state
    const initialState = lobby.state || (typeof takeSnapshot === 'function' ? takeSnapshot() : {});
    const hostColor = lobby.hostColor || 'red';
    createRoom(initialState, hostColor).then(roomId=>{
      // update lobby with started status and roomId
      window.__pe_firebase_mod.update(lobbyRef, { status: 'started', roomId: roomId }).then(()=>{
        console.log('lobby updated with roomId', roomId);
      }).catch(e=>{ console.warn('failed update lobby start', e); });
    }).catch(e=>{ console.warn('failed createRoom from lobby', e); });
  });
}

function leaveRoom(){
  if(!firebaseDb) return;
  try{ if(_roomListenerUnsubscribe){ _roomListenerUnsubscribe(); _roomListenerUnsubscribe = null; } }catch(e){}
  multiplayerRoomId = null;
  // clear assigned player color when leaving
  myPlayerColor = null;
  // cleanup meta and rematch listeners
  try{ if(_roomMetaUnsub){ _roomMetaUnsub(); _roomMetaUnsub = null; } }catch(e){}
  try{ if(_roomRematchUnsub){ _roomRematchUnsub(); _roomRematchUnsub = null; } }catch(e){}
  lastRoomMeta = null; _myRematchRequested = false; _lastRematchObj = null;
  try{ updateUndoRedoButtons(); }catch(e){}
}

let currentPlayer = 'red';
let dragged = null;
let chainMode = false;
let chainPawn = null;
let chainCount = 0;
let chainPrevIdx = null; // index the chain pawn came from (allow stepping back)
let chainAllowLastMove = false; // when true, allow one final non-capture decision at end of a chain
let scores = { red:0, blue:0 };

const MAX_PAWNS_PER_PLAYER = 5;

// AI settings
let aiEnabled = false;            // toggle whether AI takes turns (OFF by default)
let aiColor = 'blue';            // which color the AI will play
let _aiTimer = null;             // scheduled timer id for AI thinking
let _aiSession = 0;              // incrementing token to invalidate pending AI work during undos
// AI difficulty mode. Default to 'Hard'.
let aiDifficulty = 'hard';


const undoStack = [];
const redoStack = [];
let suppressSnapshots = false;
// timer used to delay resuming the AI after user-initiated undo/redo actions.
// This lets the user press Undo multiple times quickly without the AI intervening.
let _undoAiResumeTimer = null;

const prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

function enableIdleAfterFrame(el){ if(prefersReducedMotion) return; el.style.transform = ''; requestAnimationFrame(()=> requestAnimationFrame(()=> { if(document.contains(el)) el.classList.add('idle'); })); }
function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function isDiagonal(dx, dy){ return dx === 1 && dy === 1; }

// Swipe helpers
const SWIPE_MIN_DIST = 24;
const SWIPE_MAX_TIME = 450;
const SWIPE_ANGLE_TOL = 45;
function angleDeg(dx, dy){ return Math.atan2(dy, dx) * 180 / Math.PI; }
function angleToCellDelta(dxPx, dyPx){
  const angle = angleDeg(dxPx, dyPx);
  const dirs = [
    {ang: -135, d:[-1,-1]}, {ang: -90, d:[0,-1]}, {ang: -45, d:[1,-1]},
    {ang: 180, d:[-1,0]},                   {ang: 0, d:[1,0]},
    {ang: 135, d:[-1,1]},  {ang: 90, d:[0,1]},  {ang: 45, d:[1,1]}
  ];
  let best = dirs[0], bestDiff = 360;
  for(const cand of dirs){
    let diff = Math.abs(((angle - cand.ang + 540) % 360) - 180);
    if(diff < bestDiff){ bestDiff = diff; best = cand; }
  }
  if(bestDiff > SWIPE_ANGLE_TOL) return null;
  return { dx: best.d[0], dy: best.d[1] };
}

// Audio & effects (unchanged)
let audioCtx = null;
function ensureAudioContext(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
function playCaptureMelody(level = 1, dest = null){ try { ensureAudioContext(); if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{}); const now = audioCtx.currentTime; const out = dest || audioCtx.destination; const baseFreq = 440; const seq = [0, 3, 7, 12]; const tempo = 0.12; const gainMaster = audioCtx.createGain(); gainMaster.gain.value = 0.12 * Math.min(1.6, 0.6 + 0.12 * level); gainMaster.connect(out); seq.forEach((semi, i) => { const t = now + i * tempo * (0.95 + Math.random() * 0.06); const freq = baseFreq * Math.pow(2, (semi + (level-1)*1.2) / 12); const osc = audioCtx.createOscillator(); const osc2 = audioCtx.createOscillator(); const g = audioCtx.createGain(); const filt = audioCtx.createBiquadFilter(); osc.type = 'sine'; osc2.type = 'triangle'; osc.frequency.setValueAtTime(freq * (0.98 + Math.random() * 0.02), t); osc2.frequency.setValueAtTime(freq * 1.98, t); g.gain.setValueAtTime(0.0001, t); g.gain.linearRampToValueAtTime(1.0 * (0.12 + level * 0.02), t + 0.01); g.gain.exponentialRampToValueAtTime(0.0001, t + tempo * 0.92); filt.type = 'highpass'; filt.frequency.value = 120 + level * 10; osc.connect(filt); osc2.connect(filt); filt.connect(g); g.connect(gainMaster); osc.start(t); osc.stop(t + tempo * 0.95); osc2.start(t); osc2.stop(t + tempo * 0.95); }); } catch (e) { console.warn('Audio error', e); } }
// ----------------------
// AI move logic
// ----------------------
function aiTakeTurn(session){
  // session token guards: if the global session has changed since this
  // aiTurn was scheduled, abort to avoid acting on stale state.
  if(typeof session !== 'number' || session !== _aiSession) return;
  // delegate to harder AI when selected
  if(aiDifficulty === 'hard') return aiTakeTurnHard(session);
  if(!aiEnabled) return;
  if(currentPlayer !== aiColor) return;
  // small randomized thinking delay to feel natural
  const thinkDelay = 260 + Math.floor(Math.random() * 320);
  const localSession = session;
  setTimeout(()=>{
    // if session invalidated while thinking, abort
    if(localSession !== _aiSession) return;
    (function(){
      try{
        // 1) If chain mode is active and chainPawn exists, continue capturing from it
        if(chainMode && chainPawn && chainPawn.dataset.color === aiColor){
          const caps = availableCapturesFromCell(chainPawn.parentElement);
          if(caps && caps.length > 0){
            const target = caps[Math.floor(Math.random() * caps.length)];
            dragged = chainPawn;
            try{ handleDrop(new Event('ai-capture'), target.cell); }catch(e){ console.warn('AI capture drop failed', e); }
            return;
          }
          // If there are no immediate captures from the chain pawn, the AI
          // must not move other pieces ‚Äî it may only use the one-time final
          // non-capture move (chainAllowLastMove) with the same pawn. Find a
          // legal non-capture move for the chain pawn only and perform it.
          if(chainAllowLastMove){
            try{
              const fromCell = chainPawn.parentElement;
              if(fromCell){
                const fromIdx = Number(fromCell.dataset.index);
                const fx = fromIdx % 5, fy = Math.floor(fromIdx / 5);
                const candidates = [];
                // scan the whole board to allow knight/bishop moves and distant moves
                for(let toIdx = 0; toIdx < 25; toIdx++){
                  if(toIdx === fromIdx) continue;
                  const dest = board.children[toIdx]; if(!dest) continue;
                  if(dest.querySelector('.pawn')) continue; // must be empty
                  const nx = toIdx % 5, ny = Math.floor(toIdx / 5);
                  const dx = Math.abs(nx - fx), dy = Math.abs(ny - fy);
                  // apply same chain diagonal allowance used for player swipes
                  if(isDiagonal(dx, dy)){
                    const adj1 = board.children[fy * 5 + nx];
                    const adj2 = board.children[ny * 5 + fx];
                    const adj1Empty = adj1 && !adj1.querySelector('.pawn');
                    const adj2Empty = adj2 && !adj2.querySelector('.pawn');
                    if(toIdx !== chainPrevIdx && !(adj1Empty || adj2Empty)) continue;
                  }
                  if(isValidMove(dx, dy, chainPawn, fromIdx, toIdx) || canDoubleStep(chainPawn, fromIdx, toIdx)){
                    candidates.push(dest);
                  }
                }
                if(candidates.length > 0){
                  const choice = candidates[Math.floor(Math.random() * candidates.length)];
                  dragged = chainPawn;
                  try{ handleDrop(new Event('ai-move'), choice); }catch(e){ console.warn('AI chain final move failed', e); }
                }
              }
            }catch(e){ console.warn('AI chain final-move error', e); }
          }
          // Whether we moved or not, do not allow the AI to act with other pawns while chainMode persists
          return;
        }

        // 2) Search for any capturing moves for the AI
        const captureMoves = [];
        for(let i=0;i<25;i++){
          const cell = board.children[i]; if(!cell) continue;
          const p = cell.querySelector('.pawn'); if(!p || p.dataset.color !== aiColor) continue;
          const caps = availableCapturesFromCell(cell);
          if(caps && caps.length > 0){
            captureMoves.push({ pawn: p, from: cell, caps });
          }
        }
        if(captureMoves.length > 0){
          // prefer captures that lead to further captures (simple lookahead)
          let chosen = null;
          for(const cand of captureMoves){
            for(const c of cand.caps){
              const tmpPawn = cand.pawn; const targetCell = c.cell;
              const further = availableCapturesFromCell(targetCell);
              if(further && further.length > 0){ chosen = { pawn: tmpPawn, target: targetCell }; break; }
            }
            if(chosen) break;
          }
          if(!chosen){
            const group = captureMoves[Math.floor(Math.random() * captureMoves.length)];
            const cap = group.caps[Math.floor(Math.random() * group.caps.length)];
            chosen = { pawn: group.pawn, target: cap.cell };
          }
          if(chosen){ dragged = chosen.pawn; try{ handleDrop(new Event('ai-capture'), chosen.target); }catch(e){ console.warn('AI handleDrop failed', e); } }
          return;
        }

        // 3) If AI has fewer than max pawns, randomly choose to spawn or move
        const homeRow = aiColor === 'red' ? 4 : 0;
        const canSpawn = countPawns(aiColor) < MAX_PAWNS_PER_PLAYER;
        const spawnCandidates = [];
        if(canSpawn) {
          for(let c=0;c<5;c++){
            const idx = homeRow*5 + c; const cell = board.children[idx]; if(cell && !cell.querySelector('.pawn')) spawnCandidates.push(cell);
          }
        }
        const possibleMoves = [];
        for(let i=0;i<25;i++){
          const cell = board.children[i]; if(!cell) continue;
          const p = cell.querySelector('.pawn'); if(!p || p.dataset.color !== aiColor) continue;
          const fromIdx = i; const fx = fromIdx % 5; const fy = Math.floor(fromIdx/5);
          for(let nx = fx-1; nx <= fx+1; nx++){
            for(let ny = fy-1; ny <= fy+1; ny++){
              if(nx < 0 || nx >=5 || ny < 0 || ny >=5) continue;
              const toIdx = ny*5 + nx; if(toIdx === fromIdx) continue;
              const dx = Math.abs(nx - fx), dy = Math.abs(ny - fy);
              const dest = board.children[toIdx]; if(!dest) continue;
              if(dest.querySelector('.pawn')) continue;
                    if(isValidMove(dx,dy,p,fromIdx,toIdx)){
                possibleMoves.push({ pawn: p, from: cell, to: dest });
              }
            }
          }
          if(p.dataset.moved !== 'true') {
            let doubleStepIdx = null;
            if(p.dataset.color === 'red') {
              if(fy >= 2) doubleStepIdx = (fy-2)*5 + fx;
            } else {
              if(fy <= 2) doubleStepIdx = (fy+2)*5 + fx;
            }
            if(doubleStepIdx !== null) {
              const dest = board.children[doubleStepIdx];
              if(dest && !dest.querySelector('.pawn') && canDoubleStep(p, fromIdx, doubleStepIdx)) {
                possibleMoves.push({ pawn: p, from: cell, to: dest });
              }
            }
          }
        }
        if(canSpawn && spawnCandidates.length > 0 && (possibleMoves.length === 0 || Math.random() < 0.5)) {
          const choice = spawnCandidates[Math.floor(Math.random() * spawnCandidates.length)];
          try{ onCellClick(choice); }catch(e){ console.warn('AI place failed', e); }
          return;
        }
        if(possibleMoves.length > 0){
          const mv = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
          dragged = mv.pawn;
          try{ handleDrop(new Event('ai-move'), mv.to); }catch(e){ console.warn('AI move failed', e); }
          return;
        }

        // nothing to do ‚Äî pass
      }catch(e){ console.warn('AI unexpected error', e); }
    })();
  // AI has finished its decision (or passed). No special undo-block state is used now.
  }, thinkDelay);
}

// Hard AI: simple heuristic evaluator that prefers promotion and safe moves
function aiTakeTurnHard(session){
  if(typeof session !== 'number' || session !== _aiSession) return;
  if(!aiEnabled) return;
  // small randomized thinking delay, slightly longer for Hard
  const thinkDelay = 360 + Math.floor(Math.random() * 260);
  const localSession = session;
  setTimeout(()=>{
    if(localSession !== _aiSession) return;
    try{
      // If chain mode active, prioritize continuing chain with chainPawn
      if(chainMode && chainPawn && chainPawn.dataset.color === aiColor){
        const caps = availableCapturesFromCell(chainPawn.parentElement);
        if(caps && caps.length > 0){
          // pick the capture that yields most follow-ups (prefer deeper chains)
          let best = null; let bestScore = -1;
          for(const c of caps){
            const f = availableCapturesFromCell(c.cell) || [];
            const score = 100 + (f.length * 40);
            if(score > bestScore){ bestScore = score; best = c.cell; }
          }
          if(best){ dragged = chainPawn; try{ handleDrop(new Event('ai-capture'), best); }catch(e){ console.warn('AI hard capture failed', e); } }
          return;
        }
        // no immediate captures ‚Äî allow final move if chainAllowLastMove
        if(chainAllowLastMove){
          // find safe non-capture moves for chainPawn (scan whole board so promoted pieces like knights/bishops
          // can use their full move set as the final chain move)
          const fromCell = chainPawn.parentElement; const fromIdx = Number(fromCell.dataset.index);
          const fx = fromIdx % 5, fy = Math.floor(fromIdx / 5);
          const candidates = [];
          for(let toIdx = 0; toIdx < 25; toIdx++){
            if(toIdx === fromIdx) continue;
            const dest = board.children[toIdx]; if(!dest) continue; if(dest.querySelector('.pawn')) continue;
            const nx = toIdx % 5, ny = Math.floor(toIdx / 5);
            const dx = Math.abs(nx - fx), dy = Math.abs(ny - fy);
            // respect the same diagonal-chain restriction used by handleDrop
            if(isDiagonal(dx, dy)){
              const adj1 = board.children[fy * 5 + nx];
              const adj2 = board.children[ny * 5 + fx];
              const adj1Empty = adj1 && !adj1.querySelector('.pawn');
              const adj2Empty = adj2 && !adj2.querySelector('.pawn');
              if(toIdx !== chainPrevIdx && !(adj1Empty || adj2Empty)) continue;
            }
            if(!(isValidMove(dx,dy,chainPawn,fromIdx,toIdx) || canDoubleStep(chainPawn, fromIdx, toIdx))) continue;
            const wouldBeCaptured = _wouldBeCapturedByOpponentAt(toIdx, aiColor);
            let score = (wouldBeCaptured ? -80 : 30) + (isPromotionIdx(chainPawn, toIdx) ? 180 : 0);
            // small bonus to prefer forward progress when equal safety
            score += _forwardProgressScore(chainPawn, fromIdx, toIdx);
            candidates.push({cell: dest, score});
          }
          if(candidates.length>0){
            candidates.sort((a,b)=>b.score - a.score);
            // pick top score, break ties randomly
            const topScore = candidates[0].score;
            const topGroup = candidates.filter(c=> c.score === topScore);
            const pick = topGroup[Math.floor(Math.random() * topGroup.length)];
            dragged = chainPawn;
            try{ handleDrop(new Event('ai-move'), pick.cell); }catch(e){}
          }
          return;
        }
      }

      // Build board snapshot state for evaluation
      const state = _buildState();

      // Gather all candidate moves (captures and safe moves + spawn)
      const allCandidates = [];
      // 1) captures for each pawn
      for(let i=0;i<25;i++){
        const cell = board.children[i]; if(!cell) continue; const p = cell.querySelector('.pawn'); if(!p || p.dataset.color !== aiColor) continue;
        const fromIdx = i;
        // capture targets
        const caps = availableCapturesFromCell(cell) || [];
        for(const c of caps){
          const toIdx = Number(c.idx || c.cell.dataset.index);
          let score = 150;
          // prefer captures that promote or open chains
          if(isPromotionIdx(p, toIdx)) score += 220;
          // deeper chain potential
          const further = _countFurtherCapturesAfterMove(fromIdx, toIdx, state, aiColor);
          score += further * 40;
          // avoid capture if resulting square is immediately recapturable
            const wouldBeCaptured = _wouldBeCapturedByOpponentAt(toIdx, aiColor, {fromIdx, toIdx});
            if(wouldBeCaptured) score -= 120;
            // extra penalty if the captured piece would be a promoted knight/bishop and
            // an opponent PAWN could immediately recapture ‚Äî Hard AI should avoid that.
            const promotedType = p.dataset.piece || 'pawn';
            const capturedByPawn = _wouldBeCapturedByOpponentPawnAt(toIdx, aiColor, {fromIdx, toIdx});
            if((promotedType === 'knight' || promotedType === 'bishop') && capturedByPawn){
              score -= 320; // large penalty to avoid walking into a pawn recapture
            }
          allCandidates.push({pawn: p, fromIdx, toIdx, cell: c.cell, score, type: 'capture'});
        }
        // non-capture moves around (including double-step)
        const fx = fromIdx % 5, fy = Math.floor(fromIdx/5);
        for(let nx = fx-1; nx <= fx+1; nx++){
          for(let ny = fy-1; ny <= fy+1; ny++){
            if(nx<0||nx>=5||ny<0||ny>=5) continue; const toIdx = ny*5 + nx; if(toIdx===fromIdx) continue;
            const dest = board.children[toIdx]; if(!dest) continue; if(dest.querySelector('.pawn')) continue;
            const dx = Math.abs(nx - fx), dy = Math.abs(ny - fy);
            if(!(isValidMove(dx,dy,p,fromIdx,toIdx) || canDoubleStep(p, fromIdx, toIdx))) continue;
            let score = 10; // baseline
            if(isPromotionIdx(p, toIdx)) score += 200;
            // favor advancing towards promotion row
            score += _forwardProgressScore(p, fromIdx, toIdx);
            // penalize moves that put piece in danger
            const wouldBeCaptured = _wouldBeCapturedByOpponentAt(toIdx, aiColor, {fromIdx, toIdx});
            if(wouldBeCaptured) score -= 90;
            // Extra caution: if our moving piece is a promoted knight/bishop and an opponent pawn
            // could capture the destination, avoid it strongly (Hard AI preference).
            const movedType = p.dataset.piece || 'pawn';
            const destCapturedByPawn = _wouldBeCapturedByOpponentPawnAt(toIdx, aiColor, {fromIdx, toIdx});
            if((movedType === 'knight' || movedType === 'bishop') && destCapturedByPawn){
              score -= 300;
            }
            allCandidates.push({pawn: p, fromIdx, toIdx, cell: dest, score, type: 'move'});
          }
        }
      }

      // 2) spawn candidates (if AI can spawn)
      const homeRow = aiColor === 'red' ? 4 : 0;
      if(countPawns(aiColor) < MAX_PAWNS_PER_PLAYER){
        for(let c=0;c<5;c++){
          const idx = homeRow*5 + c; const cell = board.children[idx]; if(cell && !cell.querySelector('.pawn')){
            // spawn score: slightly less than a safe move, but consider promotion if start row is opponent row (unlikely)
            let s = 18;
            allCandidates.push({pawn: null, fromIdx: null, toIdx: idx, cell: cell, score: s, type: 'spawn'});
          }
        }
      }

      if(allCandidates.length === 0){ return; }
      // choose best candidate (highest score) ‚Äî break ties randomly
      allCandidates.sort((a,b)=> b.score - a.score);
      const topScore = allCandidates[0].score;
      const topGroup = allCandidates.filter(c=> c.score === topScore);
      const choice = topGroup[Math.floor(Math.random() * topGroup.length)];
      if(!choice) return;
      if(choice.type === 'spawn'){
        try{ onCellClick(choice.cell); }catch(e){ console.warn('AI hard spawn failed', e); }
        return;
      }
      // perform move/capture by setting dragged and calling handleDrop
      try{ dragged = choice.pawn; handleDrop(new Event('ai-move'), choice.cell); }catch(e){ console.warn('AI hard move failed', e); }
    }catch(e){ console.warn('AI hard unexpected error', e); }
  }, thinkDelay);
}

// --- Helper functions used by Hard AI ---
function _buildState(){
  const s = new Array(25).fill(null);
  for(let i=0;i<25;i++){ const cell = board.children[i]; if(!cell) continue; const p = cell.querySelector('.pawn'); if(p) s[i] = { color: p.dataset.color, piece: p.dataset.piece || 'pawn' }; }
  return s;
}

function isPromotionIdx(pawnEl, toIdx){ if(!pawnEl) return false; const color = pawnEl.dataset.color; const row = Math.floor(toIdx/5); return (color === 'red' && row === 0) || (color === 'blue' && row === 4); }

function _forwardProgressScore(pawnEl, fromIdx, toIdx){ try{ const color = pawnEl.dataset.color; const fromY = Math.floor(fromIdx/5); const toY = Math.floor(toIdx/5); const dir = (color === 'red') ? -1 : 1; const progress = (toY - fromY) * dir; return Math.max(0, progress) * 12; }catch(e){ return 0; } }

// Count simple further capture opportunities after performing a capture (approximate)
function _countFurtherCapturesAfterMove(fromIdx, toIdx, state, color){
  // naive: temporarily simulate move on a shallow copy of state and count captures from toIdx
  const s = state.slice(); s[toIdx] = s[fromIdx]; s[fromIdx] = null;
  let count = 0;
  // look for captures available from toIdx using state-based check
  const fx = toIdx % 5, fy = Math.floor(toIdx/5);
  const pawn = s[toIdx]; if(!pawn) return 0;
  if(pawn.piece === 'pawn'){
    const dirs = [[-1,-1],[1,-1],[-1,1],[1,1]];
    for(const [dx,dy] of dirs){ const nx = fx+dx, ny = fy+dy; if(nx<0||nx>=5||ny<0||ny>=5) continue; const ni = ny*5 + nx; if(s[ni] && s[ni].color !== pawn.color) count++; }
  } else if(pawn.piece === 'knight'){
    const cand = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
    for(const [dx,dy] of cand){ const nx = fx+dx, ny = fy+dy; if(nx<0||nx>=5||ny<0||ny>=5) continue; const ni = ny*5 + nx; if(s[ni] && s[ni].color !== pawn.color) count++; }
  } else if(pawn.piece === 'bishop'){
    const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [sx,sy] of dirs){ let nx = fx+sx, ny = fy+sy; while(nx>=0&&nx<5&&ny>=0&&ny<5){ const ni = ny*5 + nx; if(s[ni]){ if(s[ni].color !== pawn.color) count++; break; } nx+=sx; ny+=sy; } }
  }
  return count;
}

// Return true if moving/being at 'idx' would allow opponent to capture that square
function _wouldBeCapturedByOpponentAt(idx, ourColor, simulate){
  try{
    const state = _buildState();
    // if simulate provided with fromIdx/toIdx, apply the move
    if(simulate && typeof simulate.fromIdx === 'number'){
      state[simulate.toIdx] = state[simulate.fromIdx]; state[simulate.fromIdx] = null;
    }
    const fx = idx % 5, fy = Math.floor(idx/5);
    const oppColor = ourColor === 'red' ? 'blue' : 'red';
    for(let i=0;i<25;i++){
      const p = state[i]; if(!p || p.color !== oppColor) continue;
      const sx = i % 5, sy = Math.floor(i/5);
      const dx = Math.abs(sx - fx), dy = Math.abs(sy - fy);
      if(p.piece === 'pawn'){
        if(dx === 1 && dy === 1) return true;
      } else if(p.piece === 'knight'){
        if((dx===1 && dy===2) || (dx===2 && dy===1)) return true;
      } else if(p.piece === 'bishop'){
        if(dx === dy && dx !== 0){
          // ensure path clear between i and idx according to state
          const tx = fx, ty = fy; const fx2 = sx, fy2 = sy; const stepX = (tx>fx2)?1:-1; const stepY = (ty>fy2)?1:-1; let cx = fx2 + stepX, cy = fy2 + stepY; let blocked=false;
          while(cx !== tx && cy !== ty){ const ci = cy*5 + cx; if(state[ci]){ blocked = true; break; } cx += stepX; cy += stepY; }
          if(!blocked) return true;
        }
      }
    }
    return false;
  }catch(e){ return false; }
}

// Return true if an opponent PAWN could capture the square at 'idx'
function _wouldBeCapturedByOpponentPawnAt(idx, ourColor, simulate){
  try{
    const state = _buildState();
    if(simulate && typeof simulate.fromIdx === 'number'){
      state[simulate.toIdx] = state[simulate.fromIdx]; state[simulate.fromIdx] = null;
    }
    const fx = idx % 5, fy = Math.floor(idx/5);
    const oppColor = ourColor === 'red' ? 'blue' : 'red';
    for(let i=0;i<25;i++){
      const p = state[i]; if(!p || p.color !== oppColor) continue;
      if(p.piece !== 'pawn') continue; // only pawns
      const sx = i % 5, sy = Math.floor(i/5);
      const dx = Math.abs(sx - fx), dy = Math.abs(sy - fy);
      if(dx === 1 && dy === 1) return true;
    }
    return false;
  }catch(e){ return false; }
}

// Decide AI promotion choice: 'knight' or 'bishop'
function aiChoosePromotion(pawn){
  try{
    if(!pawn) return 'knight';
    // Easy mode: keep previous behavior for familiarity
    if(aiDifficulty !== 'hard') return 'knight';
    // Hard mode: evaluate both choices and pick the higher-scoring one
    const cell = pawn.parentElement;
    const state = _buildState();
    const choices = ['knight','bishop'];
    let best = 'knight'; let bestScore = -1e9;
    // store whether each choice enables immediate capture opportunities
    const wantChainFor = {};
    for(const ch of choices){
      // simulate setting piece type
      const orig = pawn.dataset.piece;
      pawn.dataset.piece = ch;
      // count immediate capture opportunities after promotion
      const caps = availableCapturesFromCell(cell) || [];
      const capCount = caps.length;
      // count mobility (valid moves)
      let moveCount = 0;
      const fromIdx = Number(cell.dataset.index);
      const fx = fromIdx % 5, fy = Math.floor(fromIdx/5);
      for(let nx = fx-2; nx <= fx+2; nx++){
        for(let ny = fy-2; ny <= fy+2; ny++){
          if(nx<0||nx>=5||ny<0||ny>=5) continue; const toIdx = ny*5 + nx; if(toIdx===fromIdx) continue;
          const dx = Math.abs(nx - fx), dy = Math.abs(ny - fy);
          const dest = board.children[toIdx]; if(!dest) continue;
          // allow moves to empty tiles or captures
          if(dest.querySelector('.pawn')){
            if(isValidCapture(dx,dy,pawn,fromIdx,toIdx)) moveCount++;
          } else {
            if(isValidMove(dx,dy,pawn,fromIdx,toIdx) || canDoubleStep(pawn, fromIdx, toIdx)) moveCount++;
          }
        }
      }
      // promotion score: if promoted piece has immediate capture potential and mobility
      let score = capCount * 200 + moveCount * 8;
      // if promotion itself was to reach last row, small bonus for forcing tempo
      if(isPromotionIdx(pawn, fromIdx)) score += 30;
      // reverse dataset to avoid side-effects (we will call promotePawn after deciding)
      pawn.dataset.piece = orig || 'pawn';
      // consider wanting to chain if immediate captures exist or captures-with-followups
      const furtherPotential = capCount + _countFurtherCapturesAfterMove(fromIdx, fromIdx, state, pawn.dataset.color);
      wantChainFor[ch] = (capCount > 0 || furtherPotential > 0);
      if(score > bestScore){ bestScore = score; best = ch; }
    }
    // mark pawn so after promotion we can decide to continue capturing
    try{ pawn.dataset.aiWantsChain = wantChainFor[best] ? 'true' : 'false'; }catch(e){}
    return best;
  }catch(e){ return 'knight'; }
}

function playPlacementSound(){ try{ ensureAudioContext(); const now = audioCtx.currentTime; const gain = audioCtx.createGain(); gain.gain.value = 0.08; gain.connect(audioCtx.destination); const osc = audioCtx.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(660, now); osc.frequency.exponentialRampToValueAtTime(880, now + 0.09); const env = audioCtx.createGain(); env.gain.setValueAtTime(0.0001, now); env.gain.linearRampToValueAtTime(1.0, now + 0.008); env.gain.exponentialRampToValueAtTime(0.0001, now + 0.16); osc.connect(env); env.connect(gain); osc.start(now); osc.stop(now + 0.18); }catch(e){} }

// Theme removed: background music and related helpers were removed per request.

// toggle handler wired at end of file

function showPlacementEffect(cellElem){
  if(!cellElem) return;
  cellElem.style.transition = 'transform 140ms ease, box-shadow 140ms ease';
  cellElem.style.transform = 'scale(1.06)';
  setTimeout(()=> { cellElem.style.transform = ''; }, 140);

  const wrap = boardWrap;
  const rect = cellElem.getBoundingClientRect();
  const wrapRect = wrap.getBoundingClientRect();
  let px = rect.left + rect.width/2 - wrapRect.left;
  let py = rect.top + rect.height/2 - wrapRect.top;
  const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale')) || 1;
  const margin = Math.max(6, 6 * scale);
  px = clamp(px, margin, wrapRect.width - margin);
  py = clamp(py, margin, wrapRect.height - margin);

  const pop = document.createElement('div');
  pop.className = 'placement-pop';
  pop.style.position = 'absolute';
  pop.style.left = px + 'px';
  pop.style.top = py + 'px';
  pop.style.width = '8px';
  pop.style.height = '8px';
  pop.style.borderRadius = '50%';
  pop.style.pointerEvents = 'none';
  pop.style.transform = 'translate(-50%,-50%) scale(0.2)';
  pop.style.background = 'rgba(255,255,255,0.95)';
  pop.style.boxShadow = '0 4px 12px rgba(0,0,0,0.28)';
  pop.style.zIndex = 8;
  pop.style.transition = 'transform 360ms cubic-bezier(.2,.9,.3,1), opacity 360ms ease';
  boardWrap.appendChild(pop);
  requestAnimationFrame(()=> {
    pop.style.transform = 'translate(-50%,-50%) scale(1.6)';
    pop.style.opacity = '0';
  });
  setTimeout(()=> pop.remove(), 420);
}

function showExplosionAtCell(cellElem, color = 'orange') {
  if (!cellElem || !boardWrap) return;
  const cellRect = cellElem.getBoundingClientRect();
  const wrapRect = boardWrap.getBoundingClientRect();
  let cx = cellRect.left + cellRect.width / 2 - wrapRect.left;
  let cy = cellRect.top + cellRect.height / 2 - wrapRect.top;
  const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale')) || 1;
  const margin = Math.max(12, 12 * scale);
  cx = clamp(cx, margin, wrapRect.width - margin);
  cy = clamp(cy, margin, wrapRect.height - margin);

  const expl = document.createElement('div');
  expl.className = 'explosion';
  expl.style.position = 'absolute';
  expl.style.left = cx + 'px';
  expl.style.top = cy + 'px';
  expl.style.pointerEvents = 'none';
  expl.style.zIndex = 18;

  const ring = document.createElement('div');
  ring.className = 'ring';
  ring.style.borderColor = color === 'red' ? 'rgba(255,140,140,0.98)' : 'rgba(140,200,255,0.98)';
  expl.appendChild(ring);

  const flash = document.createElement('div');
  flash.className = 'flash';
  expl.appendChild(flash);

  const shock = document.createElement('div');
  shock.className = 'shock';
  expl.appendChild(shock);

  const total = 20;
  for (let i = 0; i < total; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    const angle = (i / total) * Math.PI * 2 + (Math.random() - 0.5) * 0.9;
    const dist = (50 + Math.random() * 90) * scale;
    const tx = Math.cos(angle) * dist;
    const ty = Math.sin(angle) * dist;
    p.style.setProperty('--tx', tx + 'px');
    p.style.setProperty('--ty', ty + 'px');
    p.style.width = (8 + Math.random() * 14) + 'px';
    p.style.height = p.style.width;
    p.style.animationDelay = (Math.random() * 120) + 'ms';
    p.style.background = (i % 3 === 0)
      ? 'radial-gradient(circle at 30% 30%, #fff, transparent 55%), #ff9f6b'
      : 'radial-gradient(circle at 30% 30%, #fff, transparent 55%), #ffd26b';
    expl.appendChild(p);
  }

  boardWrap.appendChild(expl);
  setTimeout(() => expl.remove(), 1000);
}

// show a short-lived trail at the given cell; color is 'red' or 'blue'
function showTrailAtCell(cellElem, color, destCell){
  if(!cellElem || !boardWrap) return;
  try{
    const cellRect = cellElem.getBoundingClientRect();
    const wrapRect = boardWrap.getBoundingClientRect();
    let cx = cellRect.left + cellRect.width / 2 - wrapRect.left;
    let cy = cellRect.top + cellRect.height / 2 - wrapRect.top;
    // compute angle towards destCell if provided so the trail orients along movement
    let angle = 0;
    let useMidpoint = false;
    let midX = cx, midY = cy, span = null;
    if(destCell && destCell !== cellElem){
      try{
        const dRect = destCell.getBoundingClientRect();
        const origCx = cellRect.left + cellRect.width/2 - wrapRect.left;
        const origCy = cellRect.top + cellRect.height/2 - wrapRect.top;
        const destCx = dRect.left + dRect.width/2 - wrapRect.left;
        const destCy = dRect.top + dRect.height/2 - wrapRect.top;
        const dx = destCx - origCx;
        const dy = destCy - origCy;
        angle = Math.atan2(dy, dx) * 180 / Math.PI;
        // midpoint between origin and dest (in wrap coords)
        midX = origCx + dx * 0.5;
        midY = origCy + dy * 0.5;
        span = Math.hypot(dx, dy);
        useMidpoint = true;
      }catch(e){ console.warn('trail calc error', e); }
    }
    const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale')) || 1;
    const margin = Math.max(8, 8 * scale);
  cx = clamp(cx, margin, wrapRect.width - margin);
  cy = clamp(cy, margin, wrapRect.height - margin);
  midX = clamp(midX, margin, wrapRect.width - margin);
  midY = clamp(midY, margin, wrapRect.height - margin);

    const trail = document.createElement('div');
    trail.className = 'trail ' + (color === 'red' ? 'trail-fire' : 'trail-sparkle');
    trail.style.position = 'absolute';
    // position the trail at the midpoint when spanning multiple tiles, otherwise at origin
    trail.style.left = (useMidpoint ? midX : cx) + 'px';
    trail.style.top = (useMidpoint ? midY : cy) + 'px';
    // if we have a span (distance) set the trail width so it stretches between origin and dest
    if(span){
      const extra = Math.max(24, 16 * scale);
      trail.style.width = Math.max(48, span + extra) + 'px';
      // keep height reasonable
      trail.style.height = Math.max(28, (24 * scale)) + 'px';
    }
    // rotate the whole trail so particle spread follows the movement direction
    trail.style.transform = `translate(-50%,-50%) rotate(${angle}deg)`;
    trail.style.zIndex = 16;

    const particleCount = 4; // create same number of particles for both colors
    for(let i=0;i<particleCount;i++){
      const el = document.createElement('div');
      if(color === 'red'){
        el.className = 'flame';
      } else {
        el.className = 'spark';
      }
      // stagger slight random delays so particles feel organic
      const delay = Math.floor(Math.random() * 120);
      el.style.animationDelay = delay + 'ms';
      trail.appendChild(el);
    }

    boardWrap.appendChild(trail);
    // keep trail visible a bit longer for emphasis (1.8s)
    setTimeout(()=>{ try{ trail.remove(); }catch(e){} }, 1800);
  }catch(e){ console.warn('trail error', e); }
}

// Flowers: single-canvas renderer (less DOM, lower CPU). Draws emoji "flowers" at a capped FPS
function initFlowers(){
  const field = document.getElementById('flowerField');
  if(!field) return;

  // If we've previously created a canvas, clean it up first
  try{
    if(field._flowerCleanup){ field._flowerCleanup(); }
  }catch(e){}

  // clear any existing contents and create a canvas that fills the flower field
  field.innerHTML = '';
  const canvas = document.createElement('canvas');
  canvas.className = 'flower-canvas';
  canvas.style.position = 'absolute';
  canvas.style.left = '0';
  canvas.style.top = '0';
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.style.pointerEvents = 'none';
  canvas.style.zIndex = 0;
  field.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  // allow theme to override flower emojis (e.g., snow theme uses ‚ùÑÔ∏è)
  const emojis = (window.currentFlowerEmojis && Array.isArray(window.currentFlowerEmojis) && window.currentFlowerEmojis.length) ? window.currentFlowerEmojis : ['üå∏','üåº','üå∫','üåª','üå∑'];

  // Flower data
  const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
  // choose a conservative count based on viewport area
  // double the computed count to increase flower density
  const count = Math.max(8, Math.round(Math.min(40, (vw * vh) / (1400 * 800) * 12))) * 2;
  const flowers = [];

  function rand(min, max){ return min + Math.random() * (max - min); }

  function resizeCanvas(){
    const rect = field.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    // if flowers empty, populate; otherwise, clamp positions inside new size
    if(flowers.length === 0){
      for(let i=0;i<count;i++){
        // make flowers ~10x larger than before and slow their fall dramatically
        // then apply the user's requested adjustments: reduce size by 30% and halve speed
  const raw = Math.round(rand(100, 280));
  // reduce size by 50% per user request (half the previous raw size)
  const reduced = Math.max(8, Math.round(raw * 0.5));
        flowers.push({
          x: rand(0, w),
          y: rand(0, h),
          size: reduced,
          baseSize: reduced,
          // previous speed was rand(6,28)/1000 (px/ms) after the 10x slowdown
          // halve that speed per user request => divide by 2000
          speed: rand(6, 28) / 2000,
          emoji: emojis[Math.floor(Math.random()*emojis.length)],
          rot: rand(-0.6,0.6),
          rotSpeed: rand(-0.0002,0.00036),
          alpha: rand(0.10, 0.26),
          floatPhase: Math.random() * Math.PI * 2
        });
      }
    } else {
      for(const f of flowers){
        f.x = Math.max(0, Math.min(w, f.x));
        f.y = Math.max(0, Math.min(h, f.y));
      }
    }
  }

  // Animation control
  let lastTs = 0;
  const FPS = 30;
  const frameInterval = 1000 / FPS;
  let rafId = null;
  let pauseTimer = null;

  function drawFrame(ts){
    // if overlays open or document hidden, pause drawing and poll occasionally
    if(document.hidden || (typeof isAnyOverlayOpen === 'function' && isAnyOverlayOpen())){
      if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
      if(pauseTimer) clearTimeout(pauseTimer);
      pauseTimer = setTimeout(()=>{ pauseTimer = null; rafId = requestAnimationFrame(drawFrame); }, 600);
      return;
    }

    if(!lastTs) lastTs = ts;
    const delta = ts - lastTs;
    if(delta < frameInterval){
      rafId = requestAnimationFrame(drawFrame);
      return;
    }
    lastTs = ts;

    const rect = canvas.getBoundingClientRect();
    const w = rect.width; const h = rect.height;
    ctx.clearRect(0,0,w,h);

    for(const f of flowers){
      // update position (gentle floating)
      const dt = delta;
      f.y += f.speed * dt * (0.6 + Math.sin(f.floatPhase + ts/900) * 0.6);
      f.x += Math.sin((ts + f.x) / 1600) * 0.02 * (f.size/18);
      f.rot += f.rotSpeed * dt;
      f.floatPhase += dt * 0.0012;
      // wrap vertically
      if(f.y > h + f.size) f.y = -f.size;
      if(f.y < -f.size) f.y = h + f.size;
      if(f.x > w + f.size) f.x = -f.size;
      if(f.x < -f.size) f.x = w + f.size;

      ctx.save();
      ctx.globalAlpha = f.alpha;
      ctx.translate(f.x, f.y);
      ctx.rotate(f.rot);
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      // font fallback to system emoji-capable font; size scales gently
      const drawSize = f.baseSize * (0.86 + 0.14 * Math.sin((ts + f.x) / 900));
      ctx.font = `${Math.round(drawSize)}px serif`;
      ctx.fillText(f.emoji, 0, 0);
      ctx.restore();
    }

    rafId = requestAnimationFrame(drawFrame);
  }

  // expose cleanup so re-init can cancel previous loop/listeners
  function cleanup(){
    try{ if(rafId) cancelAnimationFrame(rafId); rafId = null; }catch(e){}
    try{ if(pauseTimer) clearTimeout(pauseTimer); pauseTimer = null; }catch(e){}
    try{ window.removeEventListener('resize', onResize); }catch(e){}
    try{ document.removeEventListener('visibilitychange', onVisibility); }catch(e){}
    // remove canvas
    try{ if(canvas && canvas.parentElement) canvas.parentElement.removeChild(canvas); }catch(e){}
  }

  function onResize(){
    // debounce resize
    if(field._flowerResizeTimer) clearTimeout(field._flowerResizeTimer);
    field._flowerResizeTimer = setTimeout(()=>{ resizeCanvas(); }, 240);
  }
  function onVisibility(){
    // on visibility change, just kick the loop so it can pause/resume quickly
    if(document.hidden){ if(rafId){ cancelAnimationFrame(rafId); rafId = null; } }
    else { if(!rafId) rafId = requestAnimationFrame(drawFrame); }
  }

  window.addEventListener('resize', onResize);
  document.addEventListener('visibilitychange', onVisibility);

  // store cleanup hook on field so repeated initFlowers calls can tear down
  field._flowerCleanup = cleanup;

  // initialize sizes and start loop
  resizeCanvas();
  rafId = requestAnimationFrame(drawFrame);
}

// Snapshots
function takeSnapshot(){
  const boardArr = new Array(25).fill(null);
  for(let i=0;i<25;i++){
    const cell = board.children[i];
    if(!cell) continue;
    const pawnEl = cell.querySelector('.pawn');
    const isCapturedRed = cell.classList.contains('captured-red');
    const isCapturedBlue = cell.classList.contains('captured-blue');
    const captured = isCapturedRed || isCapturedBlue;
    if(pawnEl){
      // There is a pawn DOM in this cell ‚Äî record its color, piece type and moved flag.
      boardArr[i] = { pawn: pawnEl.dataset.color, piece: pawnEl.dataset.piece || 'pawn', moved: pawnEl.dataset.moved === 'true', captured: captured, capturedBy: captured ? (isCapturedRed ? 'red' : 'blue') : null };
    } else if(captured){
      // Tile is captured but no pawn DOM is present (a previously captured tile).
      boardArr[i] = { pawn: null, moved: false, captured: true, capturedBy: isCapturedRed ? 'red' : 'blue' };
    } else {
      boardArr[i] = null;
    }
  }
  return {
    board: boardArr,
    currentPlayer,
    scores: { red: scores.red, blue: scores.blue },
    chainMode: !!chainMode,
    chainCount: chainCount || 0,
    chainPawnIdx: (chainPawn && chainPawn.parentElement) ? Number(chainPawn.parentElement.dataset.index) : null,
    chainPrevIdx: (typeof chainPrevIdx === 'number') ? chainPrevIdx : null,
    chainAllowLastMove: !!chainAllowLastMove,
    ts: Date.now()
  };
}

function applySnapshot(snapshot){
  if(!snapshot){
    console.warn('applySnapshot skipped: missing snapshot', snapshot);
    return;
  }

  // Firebase Realtime Database often stores arrays as plain objects with
  // numeric keys. Accept that shape by normalizing a board object -> array
  // so downstream code can assume an Array.
  if(!Array.isArray(snapshot.board) && snapshot.board && typeof snapshot.board === 'object'){
    try{
      console.warn('applySnapshot: normalizing board object -> array', { keys: Object.keys(snapshot.board || {}) });
      const arr = new Array(25).fill(null);
      Object.keys(snapshot.board || {}).forEach(k => {
        const idx = Number(k);
        if(!Number.isNaN(idx) && idx >= 0 && idx < 25) arr[idx] = snapshot.board[k];
      });
      // copy snapshot so we don't mutate the original object returned by the SDK
      snapshot = Object.assign({}, snapshot, { board: arr });
    }catch(e){ console.warn('applySnapshot: normalization failed', e); }
  }

  if(!Array.isArray(snapshot.board)){
    console.warn('applySnapshot skipped: invalid snapshot.board (not an array) after normalization', snapshot);
    return;
  }

  // Before we mutate the DOM, detect simple pawn moves so we can show trails
  // for remote updates (players moving on another client). This heuristic
  // matches pawns by color and proximity and won't be perfect, but it
  // produces a visible trail for most single-pawn moves.
  let remoteMovementPairs = [];
  let remoteCaptureEvents = [];
  try{
    const isRemote = snapshot._meta && snapshot._meta.updatedBy && snapshot._meta.updatedBy !== myClientId;
    if(isRemote && Array.isArray(snapshot.board) && board && board.children && board.children.length === 25){
      const prevPositions = [];
      for(let i=0;i<25;i++){ const c = board.children[i]; if(!c) continue; const p = c.querySelector('.pawn'); if(p) prevPositions.push({ idx: i, color: p.dataset.color }); }
      const usedSrc = new Set();
      for(let j=0;j<25;j++){
        const entry = snapshot.board[j];
        // detect remote capture events: incoming snapshot marks tile as captured
        // but previous DOM did not show it. Use capturedBy or pawn color for effect.
        try{
          const prevCell = board.children[j];
          const prevCaptured = prevCell && (prevCell.classList.contains('captured-red') || prevCell.classList.contains('captured-blue'));
          const incomingCaptured = entry && !!entry.captured;
          if(incomingCaptured && !prevCaptured){
            const ccolor = (entry && entry.capturedBy) ? entry.capturedBy : (entry && entry.pawn) ? entry.pawn : null;
            if(ccolor) remoteCaptureEvents.push({ idx: j, color: ccolor });
            else remoteCaptureEvents.push({ idx: j, color: 'red' });
          }
        }catch(e){ /* ignore capture detect errors */ }
        if(!entry || !entry.pawn) continue;
        const destCell = board.children[j];
        const destPawn = destCell && destCell.querySelector && destCell.querySelector('.pawn');
        // If destination already has a pawn of same color, assume no visible movement
        if(destPawn && destPawn.dataset.color === entry.pawn) continue;
        // find nearest source pawn of same color that is not claimed and that
        // in the incoming snapshot is either empty or contains a different pawn
        let best = null; let bestDist = 1e9;
        for(const src of prevPositions){
          if(src.color !== entry.pawn) continue;
          if(usedSrc.has(src.idx)) continue;
          const incomingAtSrc = (Array.isArray(snapshot.board) ? snapshot.board[src.idx] : null);
          // if incoming still has a pawn at src with same color, likely not moved
          if(incomingAtSrc && incomingAtSrc.pawn === src.color) continue;
          const dist = Math.abs(src.idx - j);
          if(dist < bestDist){ bestDist = dist; best = src; }
        }
        if(best){ remoteMovementPairs.push({ fromIdx: best.idx, toIdx: j, color: entry.pawn }); usedSrc.add(best.idx); }
      }
    }
  }catch(e){ console.warn('applySnapshot: movement diff detect err', e); }

  suppressSnapshots = true;
  console.log('applySnapshot: applying snapshot from', snapshot._meta && snapshot._meta.updatedBy, 'ts=', snapshot._meta && snapshot._meta.ts);
  // Always restore currentPlayer from snapshot
  try{
    // First, normalize all cells: remove pawn DOM and captured classes, then
    // re-add the checkerboard class (white/black) so styling is consistent.
    for(let i=0;i<25;i++){
      const cell = board.children[i];
      if(!cell) continue;
      // Remove existing pawn DOM
      const existingPawn = cell.querySelector('.pawn');
      if(existingPawn) existingPawn.remove();
      // Also remove any leftover promo glyphs so remote snapshot rebuilds don't
      // leave stale badges behind when pawns move between clients.
      try{
        const staleGlyphs = cell.querySelectorAll('.promoGlyph');
        if(staleGlyphs && staleGlyphs.length){ staleGlyphs.forEach(g=>{ try{ g.remove(); }catch(e){} }); }
      }catch(e){}
      cell.classList.remove('captured-red','captured-blue','white','black');
      cell.classList.add((Math.floor(i/5) + i%5) % 2 === 0 ? 'white' : 'black');
    }

    // Rebuild cells from snapshot entries. Important: only create/append a
    // pawn DOM when the snapshot entry explicitly contains a pawn. For tiles
    // that are captured but have no pawn DOM (previously captured tiles left
    // behind), we must not append a pawn ‚Äî only apply the captured-* class.
    for(let i=0;i<25;i++){
      const entry = snapshot.board[i];
      const cell = board.children[i];
      if(!cell) continue;

      if(entry && entry.captured && entry.pawn == null){
        // Captured tile with no pawn DOM: show the captured class only.
        if(entry.capturedBy === 'red') cell.classList.add('captured-red');
        else if(entry.capturedBy === 'blue') cell.classList.add('captured-blue');
        continue;
      }

      if(entry && entry.pawn){
        // There should be a pawn DOM here ‚Äî recreate it and set moved flag.
        const pawn = makePawn(entry.pawn);
        pawn.dataset.moved = entry.moved ? 'true' : 'false';
        cell.appendChild(pawn);
        pawn.__enableIdleAfterAppend && pawn.__enableIdleAfterAppend();
        // Restore promotion state if snapshot recorded it (recreate visuals)
        try{
          // Ensure explicit data-* attributes are present (defensive for remote DOM reconstruction)
          try{ pawn.setAttribute('data-color', entry.pawn); }catch(e){}
          if(entry.piece && entry.piece !== 'pawn'){
            // set dataset and recreate promo visuals (promoGlyph/promoRing)
            try{ pawn.setAttribute('data-piece', entry.piece); pawn.dataset.piece = entry.piece; }catch(e){}
            try{ promotePawn(pawn, entry.piece); }catch(e){ /* non-fatal */ }
            // Ensure promoted class is applied exactly as play-time would
            try{ pawn.classList.remove('promoted-bishop','promoted-knight'); pawn.classList.add(entry.piece === 'bishop' ? 'promoted-bishop' : 'promoted-knight'); }catch(e){}
            // Ensure promoGlyph color class mirrors team (defensive)
            try{
              const cellPg = cell.querySelector('.promoGlyph');
              if(cellPg){ cellPg.classList.remove('team-red','team-blue'); cellPg.classList.add(entry.pawn === 'red' ? 'team-red' : 'team-blue'); }
            }catch(e){}
          } else {
            try{ pawn.setAttribute('data-piece', 'pawn'); pawn.dataset.piece = 'pawn'; }catch(e){}
          }
        }catch(e){ /* ignore promotion restore errors */ }
        // If this pawn occupies a captured tile, restore the captured class
        if(entry.captured && entry.capturedBy){
          if(entry.capturedBy === 'red') cell.classList.add('captured-red');
          else if(entry.capturedBy === 'blue') cell.classList.add('captured-blue');
        }
        continue;
      }

      // Empty, non-captured tile ‚Äî ensure no captured class and no pawn DOM
      cell.classList.remove('captured-red','captured-blue');
      // nothing to append
    }

    scores = { red: snapshot.scores.red, blue: snapshot.scores.blue };
    chainMode = !!snapshot.chainMode;
    chainCount = snapshot.chainCount || 0;
    chainPawn = null;
    chainPrevIdx = (typeof snapshot.chainPrevIdx === 'number') ? snapshot.chainPrevIdx : null;
    chainAllowLastMove = !!snapshot.chainAllowLastMove;
    if(typeof snapshot.chainPawnIdx === 'number' && snapshot.chainPawnIdx >= 0 && snapshot.chainPawnIdx < 25){
      const cpCell = board.children[snapshot.chainPawnIdx];
      if(cpCell) chainPawn = cpCell.querySelector('.pawn');
    }
  } finally {
    suppressSnapshots = false;
  }

  currentPlayer = snapshot.currentPlayer;
  updateStatus();
  updateUndoRedoButtons();

  // After DOM has been updated, play remote movement trails we detected earlier
  try{
    if(remoteMovementPairs && remoteMovementPairs.length){
      for(const m of remoteMovementPairs){
        try{
          const fromCell = board.children[m.fromIdx];
          const toCell = board.children[m.toIdx];
          if(fromCell && toCell) showTrailAtCell(fromCell, m.color, toCell);
        }catch(e){ /* ignore per-movement errors */ }
      }
    }
    // Play explosion/capture effects for remote captures
    if(remoteCaptureEvents && remoteCaptureEvents.length){
      for(const ev of remoteCaptureEvents){
        try{
          const tgt = board.children[ev.idx];
          if(tgt){
            showExplosionAtCell(tgt, ev.color === 'red' ? 'red' : 'blue');
            try{ playCaptureMelody(Math.min(6, Math.max(1, (snapshot.chainCount || 0) + 1))); }catch(e){}
            try{ showCaptureEffect(tgt, ev.color); }catch(e){}
          }
        }catch(e){ /* ignore per-capture errors */ }
      }
    }
  }catch(e){ console.warn('applySnapshot: play remote trails err', e); }
}

function recordSnapshot(opts = { countAsMove: true }){
  if(suppressSnapshots) return;
  const { countAsMove } = opts;
  const snap = takeSnapshot();
  undoStack.push(snap);
  undoStack[undoStack.length - 1].__countAsMove = !!countAsMove;
  if(countAsMove) redoStack.length = 0;
  updateUndoRedoButtons();
  // If we're connected to a multiplayer room, push the latest snapshot to the DB
  try{
    if(typeof multiplayerRoomId === 'string' && multiplayerRoomId){
      console.log('recordSnapshot: sending snapshot to room', multiplayerRoomId, 'ts=', snap.ts);
      sendSnapshotToRoom(snap).catch(e=>{ console.warn('recordSnapshot: send failed', e); });
    } else {
      console.log('recordSnapshot: multiplayerRoomId not set, not sending');
    }
  }catch(e){ console.warn('recordSnapshot error', e); }
}
function updateUndoRedoButtons(){
  // Disable undo when there's no earlier snapshot available
  // Also disable undo/redo during a multiplayer match to prevent local
  // history manipulation while the authoritative state is synced.
  const inMultiplayer = !!multiplayerRoomId;
  // Prefer hiding the entire group container for a cleaner UI; if it's
  // missing, fall back to toggling the individual buttons.
  try{
    if(secondaryActions){
      if(inMultiplayer){
        secondaryActions.style.display = 'none';
        secondaryActions.setAttribute('aria-hidden','true');
      } else {
        secondaryActions.style.display = '';
        secondaryActions.setAttribute('aria-hidden','false');
      }
    } else {
      // fallback
      if(inMultiplayer){ undoBtn.style.display = 'none'; redoBtn.style.display = 'none'; }
      else { undoBtn.style.display = ''; redoBtn.style.display = ''; }
    }
  }catch(e){ /* ignore UI update errors */ }

  // Also hide the AI toggle while in multiplayer to avoid enabling AI mid-match
  try{
    if(typeof aiToggleBtn !== 'undefined' && aiToggleBtn){
      if(inMultiplayer){ aiToggleBtn.style.display = 'none'; aiToggleBtn.setAttribute('aria-hidden','true'); }
      else { aiToggleBtn.style.display = ''; aiToggleBtn.setAttribute('aria-hidden','false'); }
    }
  }catch(e){}

  // Keep disabled state consistent for accessibility even when hidden
  try{ undoBtn.disabled = inMultiplayer || undoStack.length <= 1; }catch(e){}
  try{ redoBtn.disabled = inMultiplayer || redoStack.length === 0; }catch(e){}
}
function undo(){
  if(multiplayerRoomId){ console.log('undo: disabled during multiplayer match'); return; }
  // Undo a single logical move. Snapshots may be grouped into multiple
  // entries per move; we pop snapshots until we remove a snapshot that was
  // marked as __countAsMove (the marker is set on the snapshot that ends a move).
  if(undoStack.length <= 1) return;
  // Pop snapshots into redoStack until we've popped at least one snapshot
  // and the last popped snapshot has __countAsMove === true
  let popped = null;
  do {
    popped = undoStack.pop();
    if(!popped) break;
    redoStack.push(popped);
  } while(undoStack.length > 0 && !popped.__countAsMove);

  // Apply the new top-of-stack snapshot (the state before the undone move)
  const prev = undoStack[undoStack.length - 1];
  if(prev) {
    applySnapshot(prev);
  }

  // Cancel any scheduled AI and debounce resuming it so the user can press
  // Undo multiple times quickly without the AI interrupting.
  if(_aiTimer){ clearTimeout(_aiTimer); _aiTimer = null; }
  // Invalidate any pending AI work so an AI action that already started
  // thinking will abort when its session token is checked.
  _aiSession++;
  if(_undoAiResumeTimer){ clearTimeout(_undoAiResumeTimer); _undoAiResumeTimer = null; }
  _undoAiResumeTimer = setTimeout(()=>{
    _undoAiResumeTimer = null;
    if(aiEnabled && currentPlayer === aiColor) scheduleAiIfNeeded(240);
  }, 620);

  updateUndoRedoButtons();
  updateStatus();
}
function redo(){
  if(multiplayerRoomId){ console.log('redo: disabled during multiplayer match'); return; }
  // Redo a single logical move: pop snapshots from redoStack and push them
  // onto undoStack until we've pushed the snapshot that ends a move
  if(redoStack.length === 0) return;
  let applied = null;
  do {
    const snap = redoStack.pop();
    if(!snap) break;
    undoStack.push(snap);
    applied = snap;
  } while(redoStack.length > 0 && applied && !applied.__countAsMove);

  // Apply the snapshot now at the top of the undoStack
  const top = undoStack[undoStack.length - 1];
  if(top) applySnapshot(top);

  // Debounce AI resumption similar to undo
  if(_aiTimer){ clearTimeout(_aiTimer); _aiTimer = null; }
  _aiSession++;
  if(_undoAiResumeTimer){ clearTimeout(_undoAiResumeTimer); _undoAiResumeTimer = null; }
  _undoAiResumeTimer = setTimeout(()=>{
    _undoAiResumeTimer = null;
    if(aiEnabled && currentPlayer === aiColor) scheduleAiIfNeeded(240);
  }, 620);

  updateUndoRedoButtons();
  updateStatus(); // Always show scoreboard
}
// Ensure AI is scheduled if undo/redo left it as the active player
function _postUndoRedo(){ scheduleAiIfNeeded(240); }

// Board init
function resetBoard(){
  board.innerHTML = '';
  scores = { red:0, blue:0 };
  currentPlayer = 'red';
  dragged = null; chainMode = false; chainPawn = null; chainCount = 0; chainPrevIdx = null;
  chainAllowLastMove = false;

  for(let i=0;i<25;i++){
    const cell = document.createElement('div');
    cell.className = 'cell ' + (((Math.floor(i/5) + i%5) % 2 === 0) ? 'white' : 'black');
    cell.dataset.index = i;
    cell.addEventListener('click', ()=> onCellClick(cell));
    cell.addEventListener('dragover', e=>e.preventDefault());
    cell.addEventListener('drop', e=> handleDrop(e, cell));
    board.appendChild(cell);
  }

  // starting pawns: blue row 0..4, red row 20..24
  for(let i=0;i<5;i++){
    const bluePawn = makePawn('blue');
    bluePawn.dataset.moved = 'false';
    board.children[i].appendChild(bluePawn);
    bluePawn.__enableIdleAfterAppend && bluePawn.__enableIdleAfterAppend();
  }
  for(let i=20;i<25;i++){
    const redPawn = makePawn('red');
    redPawn.dataset.moved = 'false';
    board.children[i].appendChild(redPawn);
    redPawn.__enableIdleAfterAppend && redPawn.__enableIdleAfterAppend();
  }

  undoStack.length = 0; redoStack.length = 0;
  undoStack.push(takeSnapshot());
  updateUndoRedoButtons();
  updateStatus();

  if (typeof initFlowers === 'function') initFlowers();
  // If AI is enabled and it's the AI's starting turn, schedule it
  scheduleAiIfNeeded(600);
}

function onCellClick(cell){
  const idx = Number(cell.dataset.index);
  const row = Math.floor(idx / 5);
  // If a chain attack is active, disallow spawning or moving any pawn other than
  // the chain pawn that performed the capture. Spawning new pawns must wait
  // until the chain is resolved. However, if the player clicks the chain
  // pawn's current cell while a one-time final decision is allowed
  // (chainAllowLastMove), consume that allowance and end the chain without
  // moving the pawn (this lets the player 'choose to stay' by clicking).
  if(chainMode && chainPawn){
    const pawnInCell = cell.querySelector('.pawn');
    // If the player clicked the chain pawn's current tile, allow them to
    // consume/end the chain immediately (no movement) ‚Äî this works at any
    // point during the chain, not only when chainAllowLastMove is set.
    if(pawnInCell === chainPawn){
      // clear chain state
      chainAllowLastMove = false;
      chainMode = false;
      chainPawn = null;
      chainCount = 0;
      chainPrevIdx = null;
      // after ending the chain, check for a win then switch turn and record
      if(!checkWinCapturedThreeInRow(currentPlayer)) {
        switchTurn();
        recordSnapshot({ countAsMove: true });
      } else {
        recordSnapshot({ countAsMove: true });
      }
      return;
    }
    // Clicking anywhere else while a chain is active should be ignored.
    return;
  }
  if((currentPlayer === 'red' && row !== 4) || (currentPlayer==='blue' && row !== 0)) return;
  if(cell.querySelector('.pawn')) return;
  if(countPawns(currentPlayer) >= MAX_PAWNS_PER_PLAYER){
    // Reached the maximum pawns for this player ‚Äî silently ignore spawn attempts.
    return;
  }

  if(chainMode && chainPawn){
    const fromIdx = Number(chainPawn.parentElement.dataset.index);
    const toIdx = idx;
    const dx = Math.abs((toIdx % 5) - (fromIdx % 5));
    const dy = Math.abs(Math.floor(toIdx / 5) - Math.floor(fromIdx / 5));
    if(isDiagonal(dx,dy)){
      return;
    }
  }

  const pawn = makePawn(currentPlayer);
  // Do NOT set moved=true here; allow double-step on first move
  cell.appendChild(pawn);
  pawn.__enableIdleAfterAppend && pawn.__enableIdleAfterAppend();
  playPlacementSound();
  showPlacementEffect(cell);
  if(!checkWinCapturedThreeInRow(currentPlayer)) {
    switchTurn();
    recordSnapshot({ countAsMove: true });
  } else {
    recordSnapshot({ countAsMove: true });
  }
}

// --- Emoji Picker Overlay (choose emoji for each player) ---
const emojiPickerOverlay = document.createElement('div');
emojiPickerOverlay.id = 'emojiPickerOverlay';
emojiPickerOverlay.className = 'emoji-picker-overlay';
emojiPickerOverlay.setAttribute('aria-hidden','false');
emojiPickerOverlay.innerHTML = `
  <div class="emoji-picker-modal">
    <div class="emoji-box" style="min-width:360px; min-height:160px;">
      <div style="margin-top:10px;text-align:center;">
        <div class="side-chooser" style="display:flex;gap:12px;justify-content:center;">
          <button type="button" class="side-option selected" data-side="red">Play as Red</button>
          <button type="button" class="side-option" data-side="blue">Play as Blue</button>
        </div>
      </div>
      <div class="emoji-chooser-row">
        <div class="emoji-chooser">
          <div class="emoji-chooser-title">Red team</div>
          <div class="emoji-options" id="emojiOptionsRed"></div>
          <div style="margin-top:8px;text-align:center;"><input id="teamNameRed" class="team-name-input" placeholder="Team name (e.g. Dragons)" /></div>
        </div>
        <div class="emoji-chooser">
          <div class="emoji-chooser-title">Blue team</div>
          <div class="emoji-options" id="emojiOptionsBlue"></div>
          <div style="margin-top:8px;text-align:center;"><input id="teamNameBlue" class="team-name-input" placeholder="Team name (e.g. Unicorns)" /></div>
        </div>
      </div>
      <div style="display:flex;gap:12px;justify-content:center;margin-top:16px;">
        <button id="emojiConfirmBtn">Confirm</button>
      </div>
    </div>
  </div>
`;
document.body.appendChild(emojiPickerOverlay);

const emojiPickerStyle = document.createElement('style');
emojiPickerStyle.textContent = `
  .emoji-picker-overlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(6,6,6,0.72); z-index:10000; }
  /* Dark theme for emoji picker: black background, white foreground */
  .emoji-picker-modal{ background:#0b0b0b;color:#fff;padding:22px;border-radius:12px; width: min(820px, 96vw); box-shadow:0 12px 48px rgba(0,0,0,0.6); text-align:center }
  /* Narrow variant for multiplayer or lobby flows: show a more compact picker */
  .emoji-picker-overlay.multiplayer .emoji-picker-modal{ width: min(520px, 92vw); }
  .emoji-chooser-row{ display:flex; gap:18px; justify-content:center; margin-top:12px }
  .emoji-chooser{ min-width:220px }
  .emoji-chooser-title{ font-weight:700; margin-bottom:8px }
  .emoji-options{ display:flex; flex-wrap:wrap; gap:8px; justify-content:center }
  .emoji-option{ cursor:pointer; padding:8px 10px; border-radius:8px; font-size:28px; border:2px solid transparent; background: rgba(255,255,255,0.04); color:#fff; }
  .emoji-option:hover{ transform:translateY(-2px); background: rgba(255,255,255,0.08); }
  .emoji-option.selected{ box-shadow:0 6px 18px rgba(0,0,0,0.12); border-color:#ccc }
  .emoji-picker-modal button{ background:#000;color:#fff;border:1px solid rgba(255,255,255,0.08);padding:8px 12px;border-radius:8px;cursor:pointer }
  .emoji-picker-modal button:hover{ background:#111 }
  .team-name-input{ width:88%; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.08); background:rgba(255,255,255,0.02); color:#fff }
  /* Side chooser buttons */
  .side-option{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:14px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.03);
    color:#fff;
    cursor:pointer;
    font-weight:800;
    font-size:1.15em;
    transition: box-shadow 160ms ease, border-color 160ms ease;
    box-shadow: 0 8px 22px rgba(0,0,0,0.18);
    flex: 0 0 160px; /* fixed width parity with coin choices */
    min-width: 140px;
    text-align:center;
    box-sizing: border-box;
  }
  .side-option:hover{ box-shadow: 0 18px 38px rgba(0,0,0,0.26); }
  .side-option.selected{
    background: linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    box-shadow: 0 18px 38px rgba(0,0,0,0.28);
    border: 3px solid rgba(255,255,255,1) !important;
    position: relative;
    z-index: 3;
  }
  /* Coin flip choice buttons (enlarged & enhanced) */
  /* curved white box around the coin title */
  .coin-title {
    font-weight:800;
    font-size:1.08em;
    margin-bottom:12px;
    letter-spacing:0.4px;
    display:inline-block;
    background: #000000; /* black box background */
    color: #ffffff; /* white text */
    padding: 10px 14px;
    border-radius: 12px;
    border: 2px solid #ffffff; /* white border */
    box-shadow: 0 8px 20px rgba(0,0,0,0.42);
    max-width: 92%;
    line-height: 1.15;
  }
  /* ensure both coin choice buttons are identical size and aligned; remove hover movement */
  .coin-choices{ display:flex; gap:14px; justify-content:center; margin-top:12px; align-items:center; }
  .coin-choice{
    padding:14px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(255,255,255,0.03);
    color:#fff;
    cursor:pointer;
    font-weight:800;
    font-size:1.15em;
    transition: box-shadow 160ms ease, border-color 160ms ease;
    box-shadow: 0 8px 22px rgba(0,0,0,0.18);
    display:flex;
    align-items:center;
    justify-content:center;
    flex: 0 0 160px; /* fixed width for parity */
    min-width: 140px;
    text-align:center;
    box-sizing: border-box;
  }
  /* on hover only change shadow/border ‚Äî do NOT translate/scale */
  .coin-choice:hover{ box-shadow: 0 18px 38px rgba(0,0,0,0.26); }
  .coin-choice.selected{
    background: linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    /* stronger shadow and thick white outline to indicate selection */
    box-shadow: 0 18px 38px rgba(0,0,0,0.28);
    border: 3px solid rgba(255,255,255,1) !important;
    position: relative;
    z-index: 3;
    /* removed transform so selected button doesn't move */
  }
  /* Color the coin choice buttons to indicate team mapping: heads -> blue, tails -> red */
  .coin-choice[data-choice="heads"]{ background: linear-gradient(90deg,#2b8cff,#1f6fe8); border-color: rgba(40,140,255,0.28); color:#fff }
  .coin-choice[data-choice="tails"]{ background: linear-gradient(90deg,#ff6b6b,#e04444); border-color: rgba(255,100,100,0.28); color:#fff }
  /* Coin result visual and spinning animation (3D coin with two faces) */
  #coinResult{ will-change: transform; display:inline-block; perspective:1200px; }
  /* make the coin 15% smaller overall by scaling the computed coin size */
  .coin{ --coin-size: calc(min(220px, 48vw) * 0.85); width:var(--coin-size); height:var(--coin-size); display:inline-block; position:relative; transform-style:preserve-3d; overflow:hidden; box-shadow: 0 18px 48px rgba(0,0,0,0.36); border-radius: 50%; }
  .coin-face{ position:absolute; left:0; top:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; border-radius:50%; backface-visibility:hidden; -webkit-backface-visibility:hidden; box-shadow: 0 12px 36px rgba(0,0,0,0.5), inset 0 8px 20px rgba(255,255,255,0.05); font-size: 0; line-height:1; }
  /* enlarge the emoji used as the coin face so it fills more of the coin */
  .coin-emoji{ display:inline-block; font-size: calc(var(--coin-size) * 0.94); line-height:1; transform: translateY(-4%); text-shadow: 0 4px 10px rgba(0,0,0,0.35); }
  .coin-face.front{ background: radial-gradient(circle at 30% 30%, #fff9d9, #ffd66b 40%, #f0b54a 70%); }
  .coin-face.back{ transform: rotateY(180deg); background: radial-gradient(circle at 30% 30%, #fbfbfb, #d6d6d6 40%, #b0b0b0 70%); }
  /* thinner rim for a subtler 3D edge */
  .coin::before{ content: ''; position:absolute; left:2px; top:2px; right:2px; bottom:2px; border-radius:50%; box-shadow: 0 0 0 3px rgba(0,0,0,0.06) inset; pointer-events:none; }
  /* spinning animation applied to the .coin element */
  .coin.spinning{ animation: coinFlip 3500ms cubic-bezier(.08,.8,.2,1); }
  @keyframes coinFlip{
    0%   { transform: rotateY(0deg)    scale(1); }
    30%  { transform: rotateY(1260deg) scale(1.08); } /* fast initial spins */
    70%  { transform: rotateY(1620deg) scale(1.04); } /* slowing down */
    100% { transform: rotateY(1800deg) scale(1); }    /* settle */
  }
  /* coin result color states */
  .coin.result-red .coin-face.front{ background: radial-gradient(circle at 30% 30%, #ffd6d6, #ff9a9a 40%, #ff6b6b 70%); }
  .coin.result-red .coin-face.back{ background: radial-gradient(circle at 30% 30%, #e7f2ff, #bfe0ff 40%, #79b9ff 70%); }
  .coin.result-blue .coin-face.front{ background: radial-gradient(circle at 30% 30%, #e7f2ff, #bfe0ff 40%, #79b9ff 70%); }
  .coin.result-blue .coin-face.back{ background: radial-gradient(circle at 30% 30%, #ffd6d6, #ff9a9a 40%, #ff6b6b 70%); }
  /* Flip button styling (prominent CTA) */
  #flipCoinBtn{ padding:14px 26px; font-size:1.12em; font-weight:800; border-radius:12px; border:none; background: linear-gradient(90deg,#ffd66b,#ffb84a); color:#111; box-shadow: 0 12px 34px rgba(0,0,0,0.32); cursor:pointer; transition: transform 140ms ease, box-shadow 140ms ease; }
  #flipCoinBtn:hover{ transform: translateY(-4px); box-shadow: 0 20px 48px rgba(0,0,0,0.36); }
  #flipCoinBtn:disabled{ opacity:0.6; cursor:not-allowed; transform:none; box-shadow: 0 8px 22px rgba(0,0,0,0.18); }
  /* curved white border around the emoji picker content (match credits/rules) */
  #emojiPickerOverlay .emoji-box{
    border: 1px solid rgba(255,255,255,0.92);
    border-radius: 14px;
    padding: calc(14px * var(--scale)) calc(16px * var(--scale));
    background: rgba(255,255,255,0.02);
    margin-top: calc(6px * var(--scale));
    text-align: center;
  }

  /* Startup mode chooser overlay: dark to match other overlays */
  #startModeOverlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(6,6,6,0.72); z-index:10001; }
  #startModeOverlay.show{ display:flex; }
  #startModeOverlay .modal-box{ width:360px; color:#fff; background:#0b0b0b; padding: calc(14px * var(--scale)) calc(16px * var(--scale)); border-radius:14px; border: 1px solid rgba(255,255,255,0.92); box-shadow:0 18px 46px rgba(0,0,0,0.32); }
`;
document.head.appendChild(emojiPickerStyle);

// default emoji choices (restricted to the allowed set)
const EMOJI_CHOICES = ['üßú‚Äç‚ôÄÔ∏è','üßô‚Äç‚ôÇÔ∏è','üòà','üê≤','ü¶Ñ','ü¶ñ','ü§°','üëΩ','ü§ñ','üí©','üò∫','üê∂','üê∏','üêî','üòá'];
// mapping from emoji to a human-friendly team name (plural where appropriate)
const EMOJI_TO_NAME = {
  'üßú‚Äç‚ôÄÔ∏è': 'Mermaids',
  'üßô‚Äç‚ôÇÔ∏è': 'Wizards',
  'üòà': 'Devils',
  'üê≤': 'Dragons',
  'ü¶Ñ': 'Unicorns',
  'ü¶ñ': 'Dinosaurs',
  'ü§°': 'Clowns',
  'üëΩ': 'Aliens',
  'ü§ñ': 'Robots',
  'üí©': 'Poopies',
  'üò∫': 'Cats',
  'üê∂': 'Dogs',
  'üê∏': 'Frogs',
  'üêî': 'Chickens',
  'üòá': 'Angels'
};
// sensible defaults from the allowed set
window.selectedEmoji = { red: 'üê≤', blue: 'ü¶Ñ' };
// store chosen team 'name' values ‚Äî default to the textual names from the mapping
window.selectedEmojiNames = { red: EMOJI_TO_NAME[window.selectedEmoji.red] || 'Red Team', blue: EMOJI_TO_NAME[window.selectedEmoji.blue] || 'Blue Team' };
// which side the human player will control (default red)
window.humanColor = 'red';
// flag to indicate coin-flip modal is active; when true, AI should not take its turn
window.coinFlipActive = false;

function buildEmojiOptions(containerId, team){
  const wrap = document.getElementById(containerId);
  if(!wrap) return;
  wrap.innerHTML = '';
  EMOJI_CHOICES.forEach(e=>{
    const btn = document.createElement('button');
    btn.className = 'emoji-option';
    btn.type = 'button';
    btn.textContent = e;
    btn.addEventListener('click', ()=>{
      window.selectedEmoji[team] = e;
      // set the team-name input to the textual name from mapping so scoreboard shows text
      try{
        const input = document.getElementById(team === 'red' ? 'teamNameRed' : 'teamNameBlue');
        if(input) input.value = EMOJI_TO_NAME[e] || e;
      }catch(err){ }
      refreshEmojiSelectionUI();
    });
    wrap.appendChild(btn);
  });
  // after building, initialize the team name input with either the stored name or a mapping
  try{
    const inR = document.getElementById('teamNameRed');
    const inB = document.getElementById('teamNameBlue');
  if(inR) inR.value = window.selectedEmojiNames && window.selectedEmojiNames.red ? window.selectedEmojiNames.red : (window.selectedEmoji.red || '');
  if(inB) inB.value = window.selectedEmojiNames && window.selectedEmojiNames.blue ? window.selectedEmojiNames.blue : (window.selectedEmoji.blue || '');
  }catch(e){}
}

function refreshEmojiSelectionUI(){
  const reds = document.getElementById('emojiOptionsRed').children;
  for(const b of reds){ b.classList.toggle('selected', b.textContent === window.selectedEmoji.red); }
  const blues = document.getElementById('emojiOptionsBlue').children;
  for(const b of blues){ b.classList.toggle('selected', b.textContent === window.selectedEmoji.blue); }
}

// When in multiplayer, the emoji picker should only allow changing the
// local player's emoji. This helper adjusts the UI to reflect that.
function adjustEmojiPickerForMultiplayer(){
  try{
    // If not in a multiplayer room, restore full UI
    const sideChooser = document.querySelector('.side-chooser');
    const teamNameRed = document.getElementById('teamNameRed');
    const teamNameBlue = document.getElementById('teamNameBlue');
    const redChooser = document.getElementById('emojiOptionsRed');
    const blueChooser = document.getElementById('emojiOptionsBlue');
    const isMultiplayer = !!multiplayerRoomId && !!myPlayerColor;
    if(!isMultiplayer){
      if(sideChooser) sideChooser.style.display = '';
      if(teamNameRed) teamNameRed.style.display = '';
      if(teamNameBlue) teamNameBlue.style.display = '';
      if(redChooser && redChooser.parentElement) redChooser.parentElement.style.display = '';
      if(blueChooser && blueChooser.parentElement) blueChooser.parentElement.style.display = '';
      if(redChooser) Array.from(redChooser.children).forEach(b=> b.style.pointerEvents = 'auto');
      if(blueChooser) Array.from(blueChooser.children).forEach(b=> b.style.pointerEvents = 'auto');
      // ensure overlay isn't marked multiplayer
      try{ if(emojiPickerOverlay) emojiPickerOverlay.classList.remove('multiplayer'); }catch(e){}
      return;
    }
    // Hide the side chooser when in multiplayer (side is assigned by room)
    if(sideChooser) sideChooser.style.display = 'none';
    // mark overlay as multiplayer so CSS can show a narrower modal
    try{ if(emojiPickerOverlay) emojiPickerOverlay.classList.add('multiplayer'); }catch(e){}
    // Only allow interacting with the current player's emoji options
    if(myPlayerColor === 'red'){
      if(teamNameBlue) teamNameBlue.style.display = 'none';
      if(blueChooser && blueChooser.parentElement) blueChooser.parentElement.style.display = 'none';
      if(teamNameRed) teamNameRed.style.display = '';
      if(redChooser && redChooser.parentElement) redChooser.parentElement.style.display = '';
      if(redChooser) Array.from(redChooser.children).forEach(b=> { b.style.pointerEvents = 'auto'; b.style.opacity = ''; });
    } else {
      if(teamNameRed) teamNameRed.style.display = 'none';
      if(redChooser && redChooser.parentElement) redChooser.parentElement.style.display = 'none';
      if(teamNameBlue) teamNameBlue.style.display = '';
      if(blueChooser && blueChooser.parentElement) blueChooser.parentElement.style.display = '';
      if(blueChooser) Array.from(blueChooser.children).forEach(b=> { b.style.pointerEvents = 'auto'; b.style.opacity = ''; });
    }
  }catch(e){ console.warn('adjustEmojiPickerForMultiplayer err', e); }
}

document.getElementById('emojiConfirmBtn').addEventListener('click', ()=>{
  // If in multiplayer, only allow changing the local player's emoji and
  // immediately sync the change to the room state. Otherwise, proceed
  // with the original single-player flow (coin flip and both teams).
  try{
    const isMultiplayer = !!multiplayerRoomId && !!myPlayerColor;
    if(isMultiplayer){
      // read only the inputs relevant to the local player
      if(myPlayerColor === 'red'){
        const nameR = (document.getElementById('teamNameRed') && document.getElementById('teamNameRed').value) ? document.getElementById('teamNameRed').value.trim() : (EMOJI_TO_NAME[window.selectedEmoji.red] || 'Red Team');
        window.selectedEmojiNames = Object.assign({}, window.selectedEmojiNames, { red: nameR });
        // selectedEmoji for red already set via option clicks; ensure UI reflects it
        // update only red pawn faces
        document.querySelectorAll('.pawn .pface').forEach(pf=>{
          const pawnEl = pf.parentElement;
          if(pawnEl && pawnEl.dataset && pawnEl.dataset.color === 'red'){
            pf.textContent = window.selectedEmoji.red;
          }
        });
      } else {
        const nameB = (document.getElementById('teamNameBlue') && document.getElementById('teamNameBlue').value) ? document.getElementById('teamNameBlue').value.trim() : (EMOJI_TO_NAME[window.selectedEmoji.blue] || 'Blue Team');
        window.selectedEmojiNames = Object.assign({}, window.selectedEmojiNames, { blue: nameB });
        document.querySelectorAll('.pawn .pface').forEach(pf=>{
          const pawnEl = pf.parentElement;
          if(pawnEl && pawnEl.dataset && pawnEl.dataset.color === 'blue'){
            pf.textContent = window.selectedEmoji.blue;
          }
        });
      }
      // refresh status UI
      updateStatus();
      // persist change to the room metadata so other clients learn the new emoji
      try{
        if(firebaseDb && multiplayerRoomId && window.__pe_firebase_mod && window.__pe_firebase_mod.update){
          const roomRef = 'rooms/' + multiplayerRoomId;
          const payload = { selectedEmoji: window.selectedEmoji, selectedEmojiNames: window.selectedEmojiNames };
          window.__pe_firebase_mod.update(roomRef, payload).catch(e=>{ console.warn('emoji: update room meta failed', e); });
        }
      }catch(e){ console.warn('emoji: persist meta err', e); }
      // hide the picker
      try{ emojiPickerOverlay.setAttribute('aria-hidden','true'); emojiPickerOverlay.style.display = 'none'; }catch(e){}
      return;
    }

    // single-player / local flow (unchanged)
    const nameR = (document.getElementById('teamNameRed') && document.getElementById('teamNameRed').value) ? document.getElementById('teamNameRed').value.trim() : (EMOJI_TO_NAME[window.selectedEmoji.red] || 'Red Team');
    const nameB = (document.getElementById('teamNameBlue') && document.getElementById('teamNameBlue').value) ? document.getElementById('teamNameBlue').value.trim() : (EMOJI_TO_NAME[window.selectedEmoji.blue] || 'Blue Team');
    window.selectedEmojiNames = { red: nameR, blue: nameB };
    // apply to existing pawns' visible faces (emoji glyphs)
    document.querySelectorAll('.pawn .pface').forEach(pf=>{
      const pawnEl = pf.parentElement;
      if(pawnEl && pawnEl.dataset && pawnEl.dataset.color){
        pf.textContent = pawnEl.dataset.color === 'red' ? window.selectedEmoji.red : window.selectedEmoji.blue;
      }
    });
    // update victory and status UI by forcing refresh
    updateStatus();
    // Skip coin flip in single-player: assign starting player deterministically
    try{
      // AI plays the opposite color of the human
      aiColor = (window.humanColor === 'red') ? 'blue' : 'red';
      // Let the human start by default
      currentPlayer = window.humanColor;
      // refresh UI and status
      updateStatus();
      // ensure coin flip modal flag is not active
      window.coinFlipActive = false;
      // hide the emoji picker overlay
      try{ emojiPickerOverlay.setAttribute('aria-hidden','true'); emojiPickerOverlay.style.display = 'none'; }catch(e){}
      // If AI is enabled and it's AI's turn (shouldn't be by default), schedule it
      if(aiEnabled && currentPlayer === aiColor) scheduleAiIfNeeded(320);
    }catch(e){ console.warn('skip coin flip fallback err', e); }
  }catch(e){ console.warn('emojiConfirm err', e); }
});

// build options and show overlay on load
buildEmojiOptions('emojiOptionsRed','red');
buildEmojiOptions('emojiOptionsBlue','blue');
refreshEmojiSelectionUI();
// Adjust the picker UI if we're already in multiplayer when the page loads
adjustEmojiPickerForMultiplayer();

// Side chooser wiring: allow player to pick red or blue at start
function refreshSideSelectionUI(){
  const buttons = document.querySelectorAll('.side-option');
  buttons.forEach(b=> b.classList.toggle('selected', b.dataset.side === window.humanColor));
}
document.querySelectorAll('.side-option').forEach(b=>{
  b.addEventListener('click', ()=>{
    window.humanColor = b.dataset.side;
    refreshSideSelectionUI();
  });
});
refreshSideSelectionUI();

// Coin flip UI: shows after Confirm so the game knows who goes first
function showCoinFlip(){
  const redName = (window.selectedEmojiNames && window.selectedEmojiNames.red) ? window.selectedEmojiNames.red : (EMOJI_TO_NAME[window.selectedEmoji.red] || 'Red');
  const blueName = (window.selectedEmojiNames && window.selectedEmojiNames.blue) ? window.selectedEmojiNames.blue : (EMOJI_TO_NAME[window.selectedEmoji.blue] || 'Blue');
  const redLabel = `Red ${redName}`;
  const blueLabel = `Blue ${blueName}`;
  // default coin choice is heads for the human
  let coinChoice = 'heads';
  // mark coin flip modal active so the AI does not take a turn until it closes
  window.coinFlipActive = true;
  emojiPickerOverlay.innerHTML = `
    <div class="emoji-picker-modal" style="text-align:center;">
      <div class="emoji-box">
          <div class="coin-title">Select heads or tails and flip the coin to see who goes first.</div>
          <div class="coin-choices">
            <label class="coin-choice selected" data-choice="heads"><input type="radio" name="coinChoice" value="heads" checked style="display:none" aria-hidden="true">Heads</label>
            <label class="coin-choice" data-choice="tails"><input type="radio" name="coinChoice" value="tails" style="display:none" aria-hidden="true">Tails</label>
          </div>
          <div style="margin:18px 0;" id="coinResult">
            <div class="coin" aria-hidden="true">
                <div class="coin-face front"><span class="coin-emoji">ü™ô</span></div>
                <div class="coin-face back"><span class="coin-emoji">ü™ô</span></div>
              </div>
          </div>
      <div style="display:flex;justify-content:center;gap:12px;">
        <button id="flipCoinBtn">Flip Coin</button>
      </div>
      </div>
    </div>
  `;
  const coinResult = document.getElementById('coinResult');
  const coinElem = coinResult ? coinResult.querySelector('.coin') : null;
  const flipBtn = document.getElementById('flipCoinBtn');
  const choiceButtons = document.querySelectorAll('.coin-choice');
  choiceButtons.forEach(b=> b.addEventListener('click', ()=>{
    coinChoice = b.dataset.choice;
    choiceButtons.forEach(x=> x.classList.toggle('selected', x === b));
  }));
  function finishWith(winner){
    currentPlayer = winner;
    // do not display a coin-flip message above the scoreboard
    // ensure AI color is opposite of human
    aiColor = (window.humanColor === 'red') ? 'blue' : 'red';
    // refresh scoreboard/status without an extra message
    updateStatus();
    // keep the coin result visible a bit longer before closing the modal
    setTimeout(()=>{
      emojiPickerOverlay.setAttribute('aria-hidden','true');
      emojiPickerOverlay.style.display = 'none';
      // coin flip modal has closed ‚Äî allow AI to act if it is their turn
      window.coinFlipActive = false;
      if(aiEnabled && currentPlayer === aiColor) scheduleAiIfNeeded(600);
    }, 2800);
  }
  flipBtn.addEventListener('click', ()=>{
    if(!coinElem) return;
  // Prevent multiple clicks: disable the flip button and lock the choice buttons
  if(flipBtn.disabled) return;
  flipBtn.disabled = true;
  flipBtn.classList.add('disabled');
  try{ choiceButtons.forEach(b=>{ b.style.pointerEvents = 'none'; /* keep .selected so the user's choice stays highlighted during spin */ }); }catch(e){}
    // start coin spin animation
    // clear any previous result styling
    coinElem.classList.remove('result-red','result-blue');
    coinElem.classList.remove('spun');
    coinElem.classList.add('spinning');
    // small visual sequence: animate the coin, then reveal winner
    setTimeout(()=>{
      const flip = Math.random() < 0.5 ? 'heads' : 'tails';
      // Map sides: heads => blue, tails => red
      const sideToTeam = { heads: 'blue', tails: 'red' };
      const winnerTeam = sideToTeam[flip];
      // stop spinning and show winning team's emoji on the front face
      coinElem.classList.remove('spinning');
      coinElem.classList.add('spun');
  const front = coinElem.querySelector('.coin-face.front');
  const back = coinElem.querySelector('.coin-face.back');
  const fSpan = front && front.querySelector('.coin-emoji');
  const bSpan = back && back.querySelector('.coin-emoji');
  if(fSpan) fSpan.textContent = winnerTeam === 'red' ? (window.selectedEmoji.red || 'üî¥') : (window.selectedEmoji.blue || 'üîµ');
  if(bSpan) bSpan.textContent = winnerTeam === 'red' ? (window.selectedEmoji.blue || 'üîµ') : (window.selectedEmoji.red || 'üî¥');
  // apply colored result class so coin face backgrounds match winner
  if(coinElem){
    coinElem.classList.remove('result-red','result-blue');
    coinElem.classList.add(winnerTeam === 'red' ? 'result-red' : 'result-blue');
  }
      finishWith(winnerTeam);
    }, 3500);
  });
  // No random button ‚Äî only allow explicit flip by player
}


function countPawns(color){ let count = 0; for(let i=0;i<board.children.length;i++){ const cell = board.children[i]; if(!cell) continue; const p = cell.querySelector('.pawn'); if(p && p.dataset.color === color) count++; } return count; }

function isValidMove(dx,dy){ return dx <= 1 && dy <= 1 && (dx + dy > 0); }
// Enhanced isValidMove supporting promoted piece types when pawn element and
// indices are provided. Backwards-compatible: callers that pass only dx,dy
// will use the original pawn movement rules.
function isValidMove(dx, dy, pawn, fromIdx, toIdx){
  try{
    if(!pawn) return (dx <= 1 && dy <= 1 && (dx + dy > 0));
    const type = pawn.dataset.piece || 'pawn';
    if(type === 'pawn') return (dx <= 1 && dy <= 1 && (dx + dy > 0));
    if(type === 'knight') return (dx === 1 && dy === 2) || (dx === 2 && dy === 1);
    if(type === 'bishop'){
      if(dx !== dy || dx === 0) return false;
      // Ensure path between fromIdx and toIdx is clear (no jumping)
      if(typeof fromIdx === 'number' && typeof toIdx === 'number'){
        const fx = fromIdx % 5, fy = Math.floor(fromIdx / 5);
        const tx = toIdx % 5, ty = Math.floor(toIdx / 5);
        const sx = (tx > fx) ? 1 : -1; const sy = (ty > fy) ? 1 : -1;
        let cx = fx + sx, cy = fy + sy;
        while(cx !== tx && cy !== ty){
          const ci = cy * 5 + cx; const cell = board.children[ci]; if(cell && cell.querySelector('.pawn')) return false;
          cx += sx; cy += sy;
        }
      }
      return true;
    }
  }catch(e){ console.warn('isValidMove err', e); }
  return false;
}

// Enhanced isValidCapture: supports pawn (diagonal step), bishop (diagonal any distance), knight (L-shape)
function isValidCapture(dx, dy, pawn, fromIdx, toIdx){
  try{
    if(!pawn) return (dx === 1 && dy === 1);
    const type = pawn.dataset.piece || 'pawn';
    if(type === 'pawn') return (dx === 1 && dy === 1);
    if(type === 'knight') return (dx === 1 && dy === 2) || (dx === 2 && dy === 1);
    if(type === 'bishop'){
      if(dx !== dy || dx === 0) return false;
      // path must be clear except possibly the destination (which will be captured)
      if(typeof fromIdx === 'number' && typeof toIdx === 'number'){
        const fx = fromIdx % 5, fy = Math.floor(fromIdx / 5);
        const tx = toIdx % 5, ty = Math.floor(toIdx / 5);
        const sx = (tx > fx) ? 1 : -1; const sy = (ty > fy) ? 1 : -1;
        let cx = fx + sx, cy = fy + sy;
        while(cx !== tx && cy !== ty){
          const ci = cy * 5 + cx; const cell = board.children[ci]; if(cell && cell.querySelector('.pawn')) return false;
          cx += sx; cy += sy;
        }
      }
      return true;
    }
  }catch(e){ console.warn('isValidCapture err', e); }
  return false;
}


// New helper: canDoubleStep for first move (non-capturing, straight)
function canDoubleStep(pawn, fromIdx, toIdx){
  if(!pawn) return false;
  if(pawn.dataset.moved === 'true') return false;
  const dx = (toIdx % 5) - (fromIdx % 5);
  const dy = Math.floor(toIdx / 5) - Math.floor(fromIdx / 5);
  if(dx !== 0) return false;
  if(Math.abs(dy) !== 2) return false;
  // ensure direction is forward for the pawn
  if(pawn.dataset.color === 'red' && dy > 0) return false; // red starts bottom, forward is up (negative) ‚Äî adapt depending on your board orientation
  if(pawn.dataset.color === 'blue' && dy < 0) return false;
  // check intermediate cell empty
  const midY = Math.floor((Math.floor(fromIdx / 5) + Math.floor(toIdx / 5)) / 2);
  const midX = fromIdx % 5;
  const midIdx = midY * 5 + midX;
  const midCell = board.children[midIdx];
  if(!midCell) return false;
  if(midCell.querySelector('.pawn')) return false;
  // destination must be empty (non-capturing)
  const destCell = board.children[toIdx];
  if(!destCell) return false;
  if(destCell.querySelector('.pawn')) return false;
  return true;
}

// Generalized capture finder that supports pawn (1-diagonal), bishop (any-distance diagonal), and knight (L-shape)
// Renamed to availableCapturesFromCell to reflect support for non-diagonal captures (knight)
function availableCapturesFromCell(cellElem){
  if(!cellElem) return [];
  const idx = Number(cellElem.dataset.index); const x = idx % 5; const y = Math.floor(idx/5);
  const out = [];
  const pawn = cellElem.querySelector('.pawn'); if(!pawn) return [];
  const type = pawn.dataset.piece || 'pawn';
  if(type === 'pawn'){
    const dirs = [[-1,-1],[1,-1],[-1,1],[1,1]];
    for(const [dx,dy] of dirs){
      const nx = x + dx, ny = y + dy;
      if(nx < 0 || nx >=5 || ny < 0 || ny >=5) continue;
      const nIdx = ny*5 + nx; const neighbor = board.children[nIdx];
      const occ = neighbor.querySelector('.pawn');
      if(occ && occ.dataset.color !== pawn.dataset.color) out.push({ idx: nIdx, cell: neighbor });
    }
    return out;
  }
  if(type === 'knight'){
    const cand = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];
    for(const [dx,dy] of cand){
      const nx = x + dx, ny = y + dy; if(nx<0||nx>=5||ny<0||ny>=5) continue;
      const nIdx = ny*5 + nx; const neighbor = board.children[nIdx]; if(!neighbor) continue;
      const occ = neighbor.querySelector('.pawn'); if(occ && occ.dataset.color !== pawn.dataset.color) out.push({ idx: nIdx, cell: neighbor });
    }
    return out;
  }
  if(type === 'bishop'){
    const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [sx,sy] of dirs){
      let nx = x + sx, ny = y + sy;
      while(nx >=0 && nx < 5 && ny >=0 && ny < 5){
        const nIdx = ny*5 + nx; const neighbor = board.children[nIdx];
        const occ = neighbor.querySelector('.pawn');
        if(occ){
          if(occ.dataset.color !== pawn.dataset.color) out.push({ idx: nIdx, cell: neighbor });
          break; // blocked beyond this point
        }
        nx += sx; ny += sy;
      }
    }
    return out;
  }
  return out;
}

// Promotion helpers
function promotePawn(pawn, choice){
  try{
    if(!pawn) return;
    choice = (choice === 'knight') ? 'knight' : 'bishop';
    pawn.dataset.piece = choice;
    // Update visual: keep the team emoji, but overlay a centered small letter (B/K)
    const face = pawn.querySelector('.pface');
    const glyphChar = choice === 'bishop' ? 'B' : 'K';
    try{
      // ensure base emoji remains
      if(face){
        const baseEmoji = pawn.dataset.color === 'red' ? (window.selectedEmoji && window.selectedEmoji.red ? window.selectedEmoji.red : 'üê≤') : (window.selectedEmoji && window.selectedEmoji.blue ? window.selectedEmoji.blue : 'ü¶Ñ');
        face.textContent = baseEmoji;
      }
  // create or update promoGlyph element attached to the parent cell so
  // the badge aligns to the tile corner (top-right of the cell)
  const cell = pawn.parentElement;
  let pg = cell ? cell.querySelector('.promoGlyph') : null;
  if(!pg){ pg = document.createElement('span'); pg.className = 'promoGlyph'; cell && cell.appendChild(pg); }
  else if(pg.parentElement !== cell){ cell && cell.appendChild(pg); }
  // show a larger crown to the left of the letter (crown first)
  pg.innerHTML = '<span class="promoCrown">üëë</span><span class="promoLetter">' + glyphChar + '</span>';
      // Placement/styling for .promoGlyph is handled by the consolidated
      // stylesheet rule appended at the end of the <style> block.
      pawn.classList.remove('promoted-bishop','promoted-knight');
      pawn.classList.add(choice === 'bishop' ? 'promoted-bishop' : 'promoted-knight');
      // create or update the pulsing promo ring (neon) behind the glyph
      try{
        let pr = pawn.querySelector('.promoRing');
        if(!pr){ pr = document.createElement('span'); pr.className = 'promoRing';
          // append ring inside the pawn element (ring visually relates to pawn)
          pawn.appendChild(pr);
        }
        // normalize classes for color variants
        pr.classList.remove('red','blue');
        pr.classList.add(pawn.dataset.color === 'red' ? 'red' : 'blue');
      }catch(e){ console.warn('promotePawn ring err', e); }
      // Ensure promoGlyph color/backdrop reflects team color by toggling a data attribute
      try{
        pg.classList.remove('team-red','team-blue');
        pg.classList.add(pawn.dataset.color === 'red' ? 'team-red' : 'team-blue');
      }catch(e){ /* non-fatal */ }
    }catch(e){ console.warn('promotePawn visual update err', e); }
  }catch(e){ console.warn('promotePawn err', e); }
}

// Create a promotion overlay that matches other modal overlays (backdrop + .modal-box)
function ensurePromotionOverlay(){
  try{
    if(document.getElementById('promotionOverlay')) return document.getElementById('promotionOverlay');
    const ov = document.createElement('div'); ov.id = 'promotionOverlay'; ov.setAttribute('aria-hidden','true'); ov.style.display = 'none';
    ov.innerHTML = `
      <div class="modal-backdrop"></div>
      <div class="modal-box" role="dialog" aria-modal="true">
        <button class="modal-close" id="promotionClose">√ó</button>
        <h3 id="promotionTitle">Promote pawn</h3>
        <div class="modal-content" id="promotionContent" style="display:flex;gap:12px;justify-content:center;margin-top:8px"></div>
      </div>
    `;
    document.body.appendChild(ov);
    // minimal CSS to align with other overlays (the .modal-box rules are shared in file)
    ov.querySelector('#promotionClose').addEventListener('click', ()=>{ try{ hidePromotionOverlay(); }catch(e){} });
    return ov;
  }catch(e){ console.warn('ensurePromotionOverlay err', e); }
}

function showPromotionModal(pawn, cb){
  try{
    const ov = ensurePromotionOverlay(); if(!ov) return;
    const content = ov.querySelector('#promotionContent'); if(!content) return;
    content.innerHTML = '';
    const bB = document.createElement('button'); bB.textContent = 'Bishop ‚ôó'; bB.className = 'promo-choice';
    const bN = document.createElement('button'); bN.textContent = 'Knight ‚ôò'; bN.className = 'promo-choice';
    content.appendChild(bB); content.appendChild(bN);
    // show overlay
    ov.style.display = 'flex'; ov.setAttribute('aria-hidden','false'); ov.classList.add('show');
    // disable board interactions while promotion choice is open
    try{ board.style.pointerEvents = 'none'; }catch(e){}
    const cleanup = (choice)=>{
      try{ ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); ov.style.display = 'none'; }catch(e){}
      try{ board.style.pointerEvents = ''; }catch(e){}
      try{ if(typeof cb === 'function') cb(choice); }catch(e){}
    };
    bB.onclick = ()=>{ try{ promotePawn(pawn,'bishop'); cleanup('bishop'); }catch(e){ console.warn(e); } };
    bN.onclick = ()=>{ try{ promotePawn(pawn,'knight'); cleanup('knight'); }catch(e){ console.warn(e); } };
  }catch(e){ console.warn('showPromotionModal err', e); }
}

function hidePromotionOverlay(){ try{ const ov = document.getElementById('promotionOverlay'); if(!ov) return; ov.classList.remove('show'); ov.setAttribute('aria-hidden','true'); ov.style.display = 'none'; try{ board.style.pointerEvents = ''; }catch(e){} }catch(e){} }

// handleDrop: updated to allow double-step on first move
function handleDrop(e, targetCell){
  e.preventDefault && e.preventDefault();
  if(!dragged) return;
  const pawn = dragged;
  const fromCell = pawn.parentElement;
  if(!fromCell){ dragged = null; return; }
  const fromIdx = Number(fromCell.dataset.index), toIdx = Number(targetCell.dataset.index);
  const dx = Math.abs((toIdx % 5) - (fromIdx % 5));
  const dy = Math.abs(Math.floor(toIdx / 5) - Math.floor(fromIdx / 5));
  // allow normal king-step moves or first-move double-step
  if(!(isValidMove(dx,dy,pawn,fromIdx,toIdx) || canDoubleStep(pawn, fromIdx, toIdx))) return;

  const existing = targetCell.querySelector('.pawn');

  // If a chain is active, disallow diagonal moves that are not captures
  if(chainMode && chainPawn){
    if(isDiagonal(dx,dy) && !(existing && existing.dataset.color !== pawn.dataset.color)){
      // allow diagonal non-capture moves during a chain if at least one orthogonal
      // adjacent tile in the movement L-shape is empty (provides a clear path)
      const fx = fromIdx % 5, fy = Math.floor(fromIdx/5);
      const tx = toIdx % 5, ty = Math.floor(toIdx/5);
      const adj1 = board.children[fy * 5 + tx]; // tile at (tx, fy)
      const adj2 = board.children[ty * 5 + fx]; // tile at (fx, ty)
      const adj1Empty = adj1 && !adj1.querySelector('.pawn');
      const adj2Empty = adj2 && !adj2.querySelector('.pawn');
      // allow stepping back to the previous square of the chain pawn
      if(toIdx === chainPrevIdx) {
        // permitted if the previous square is empty (should be empty because pawn moved)
      } else if(!(adj1Empty || adj2Empty)){
        return;
      }
    }
  }

  // Capture branch (diagonal capture)
  if(existing && existing.dataset.color !== pawn.dataset.color && isValidCapture(dx,dy,pawn,fromIdx,toIdx)){
    existing.classList.add('captured');
    showExplosionAtCell(targetCell, pawn.dataset.color === 'red' ? 'red' : 'blue');
    playCaptureMelody(Math.min(6, Math.max(1, chainCount + 1)));
    setTimeout(()=>{
      // leave a trail behind at the origin cell when a pawn moves, oriented toward the destination
      try{ if(fromCell && fromCell !== targetCell) showTrailAtCell(fromCell, pawn.dataset.color, targetCell); }catch(e){}
      targetCell.innerHTML = '';
      targetCell.classList.remove('white','black','captured-red','captured-blue');
      targetCell.classList.add(pawn.dataset.color === 'red' ? 'captured-red' : 'captured-blue');
      targetCell.appendChild(pawn);

      // process common post-append logic (handles promotion and chain logic)
      afterPawnPlaced(pawn, fromIdx, targetCell, true);
    }, 220);
    return;
  }

  // Non-capture branch ‚Äî includes single-step moves and double-step first move
  if(existing) return;
  // perform move
  // leave a trail at the origin cell when a pawn moves, oriented toward the destination
  try{ if(fromCell && fromCell !== targetCell) showTrailAtCell(fromCell, pawn.dataset.color, targetCell); }catch(e){}
  targetCell.appendChild(pawn);
  // process common post-append logic for non-capture
  afterPawnPlaced(pawn, fromIdx, targetCell, false);
}

// Helper: called after a pawn element has been appended to a target cell.
// Handles marking moved, capture vs placement effects, promotion, and
// chain/turn resolution. 'wasCapture' should be true when the move captured.
function afterPawnPlaced(pawn, fromIdx, targetCell, wasCapture){
  try{
    pawn.classList.remove('dragging');
    pawn.__enableIdleAfterAppend && pawn.__enableIdleAfterAppend();
    pawn.dataset.moved = 'true';
    // If this pawn has a promo badge in its previous cell, move it with the pawn
    try{
      if(typeof fromIdx === 'number' && fromIdx >= 0){
        const fromCellElem = board.children[fromIdx];
        if(fromCellElem && fromCellElem !== targetCell){
          const pg = fromCellElem.querySelector('.promoGlyph');
          if(pg) targetCell.appendChild(pg);
        }
      }
    }catch(e){}
    if(wasCapture){
      scores[currentPlayer]++; chainCount++;
      showCaptureEffect(targetCell, pawn.dataset.color);
      // If this capture created a run of three captured tiles for the current
      // player, immediately end the game and show the victory screen.
      // checkWinCapturedThreeInRow calls endGame() internally when true.
      try{
        if(checkWinCapturedThreeInRow(currentPlayer)){
          // Persist snapshot for multiplayer observers and return early.
          recordSnapshot({ countAsMove: true });
          return;
        }
      }catch(e){ console.warn('win check after capture failed', e); }
    } else {
      playPlacementSound();
      showPlacementEffect(targetCell);
    }

    const toIdx = Number(targetCell.dataset.index);
    const needsPromote = (pawn.dataset.piece === 'pawn') && ((pawn.dataset.color === 'red' && Math.floor(toIdx/5) === 0) || (pawn.dataset.color === 'blue' && Math.floor(toIdx/5) === 4));

    const continueAfterPromotion = ()=>{
      try{
        if(wasCapture){
          const further = availableCapturesFromCell(targetCell);
          if(further.length > 0){
            chainMode = true; chainPawn = pawn; chainPrevIdx = fromIdx; dragged = pawn; recordSnapshot({ countAsMove: true }); updateStatus();
            if(aiEnabled && pawn.dataset.color === aiColor){ setTimeout(()=> scheduleAiIfNeeded(260), 260); }
          } else {
            chainMode = true; chainPawn = pawn; chainPrevIdx = fromIdx; chainAllowLastMove = true; dragged = pawn; recordSnapshot({ countAsMove: true }); updateStatus();
            if(aiEnabled && pawn.dataset.color === aiColor){ setTimeout(()=> scheduleAiIfNeeded(260), 260); }
          }
        } else {
          if(chainAllowLastMove && pawn === chainPawn){
            chainAllowLastMove = false; chainMode = false; chainPawn = null; chainCount = 0; chainPrevIdx = null;
            if(!checkWinCapturedThreeInRow(currentPlayer)) { switchTurn(); recordSnapshot({ countAsMove: true }); } else { recordSnapshot({ countAsMove: true }); }
            return;
          }
          if(!checkWinCapturedThreeInRow(currentPlayer)) { switchTurn(); recordSnapshot({ countAsMove: true }); } else { recordSnapshot({ countAsMove: true }); }
        }
      }catch(e){ console.warn('afterPawnPlaced continue err', e); }
    };

    if(needsPromote){
      // Determine whether the local human should choose the promotion.
      // In multiplayer the human controls the side if myPlayerColor matches pawn color.
      // In single-player, the human should NOT be offered choice for the AI-controlled color (aiColor).
      const humanControls = (multiplayerRoomId) ? (myPlayerColor && pawn.dataset.color === myPlayerColor) : (pawn.dataset.color !== aiColor);
      if(humanControls){
        // show choice UI to the human controlling this pawn
        showPromotionModal(pawn, choice=>{ promotePawn(pawn, choice); continueAfterPromotion(); });
      } else {
        // AI: decide whether to promote to knight or bishop
        try{
          const choice = (typeof aiChoosePromotion === 'function') ? aiChoosePromotion(pawn) : 'knight';
          promotePawn(pawn, choice);
        }catch(e){
          // fallback
          promotePawn(pawn, 'knight');
        }
        // If the hard AI indicated it wants to continue capturing after promotion,
        // and there are captures available from the promoted pawn, start chain mode
        try{
          if(pawn.dataset && pawn.dataset.aiWantsChain === 'true'){
            const postCaps = availableCapturesFromCell(targetCell) || [];
            if(postCaps.length > 0){
              chainMode = true; chainPawn = pawn; chainPrevIdx = fromIdx; dragged = pawn; recordSnapshot({ countAsMove: true }); updateStatus();
              if(aiEnabled && pawn.dataset.color === aiColor){ setTimeout(()=> scheduleAiIfNeeded(260), 260); }
              // clear the AI flag now that it's consumed
              try{ delete pawn.dataset.aiWantsChain; }catch(e){}
              return;
            }
          }
        }catch(e){ /* non-fatal */ }
        // clear the AI flag if present
        try{ delete pawn.dataset.aiWantsChain; }catch(e){}
        continueAfterPromotion();
      }
    } else {
      continueAfterPromotion();
    }
  }catch(e){ console.warn('afterPawnPlaced err', e); }
}

function switchTurn(){ currentPlayer = currentPlayer === 'red' ? 'blue' : 'red'; updateStatus(); dragged = null; chainMode = false; chainPawn = null; chainCount = 0; chainPrevIdx = null; chainAllowLastMove = false; scheduleAiIfNeeded(); }
// When turn switches, if AI is enabled and it's the AI's color, schedule its move.
function scheduleAiIfNeeded(delay = 420){
  if(_aiTimer){ clearTimeout(_aiTimer); _aiTimer = null; }
  // If any overlay/picker/modal is open, defer AI until it closes
  if(typeof isAnyOverlayOpen === 'function' ? isAnyOverlayOpen() : (window.coinFlipActive)) return;
  if(!aiEnabled) return;
  if(currentPlayer !== aiColor) return;
  _aiTimer = setTimeout(()=>{ _aiTimer = null; try{ aiTakeTurn(_aiSession); }catch(e){ console.warn('AI error', e); } }, delay);
}

// Return true if any known modal/overlay is currently visible/open.
function isAnyOverlayOpen(){
  try{
    // Check the main overlays by id if they exist
    const ids = ['emojiPickerOverlay','promotionOverlay','rulesOverlay','victoryOverlay','creditsOverlay'];
    for(const id of ids){
      const el = document.getElementById(id);
      if(!el) continue;
      // If aria-hidden is explicitly false or the element is visible in layout, consider it open
      const aria = el.getAttribute('aria-hidden');
      if(aria === 'false') return true;
      const style = window.getComputedStyle(el);
      if(style && style.display !== 'none' && style.visibility !== 'hidden' && parseFloat(style.opacity || '1') > 0) return true;
      if(el.classList && el.classList.contains('show')) return true;
    }
  }catch(e){ /* ignore and fall through */ }
  return false;
}

function showCaptureEffect(cell,color){ cell.style.transition = 'transform .18s ease, box-shadow .18s ease'; cell.style.transform = 'scale(1.04)'; setTimeout(()=>{ cell.style.transform = ''; }, 160); }
function capturedOwnerOf(index){ const cell = board.children[index]; if(!cell) return null; if(cell.classList.contains('captured-red')) return 'red'; if(cell.classList.contains('captured-blue')) return 'blue'; return null; }

function checkCapturedRunOfThreeForColor(color){
  for(let r=0;r<5;r++){ for(let c=0;c<=2;c++){ if(capturedOwnerOf(r*5 + c) === color && capturedOwnerOf(r*5 + c+1) === color && capturedOwnerOf(r*5 + c+2) === color) return true; } }
  for(let c=0;c<5;c++){ for(let r=0;r<=2;r++){ if(capturedOwnerOf(r*5 + c) === color && capturedOwnerOf((r+1)*5 + c) === color && capturedOwnerOf((r+2)*5 + c) === color) return true; } }
  for(let r=0;r<=2;r++){ for(let c=0;c<=2;c++){ if(capturedOwnerOf(r*5 + c) === color && capturedOwnerOf((r+1)*5 + c+1) === color && capturedOwnerOf((r+2)*5 + c+2) === color) return true; } }
  for(let r=2;r<5;r++){ for(let c=0;c<=2;c++){ if(capturedOwnerOf(r*5 + c) === color && capturedOwnerOf((r-1)*5 + c+1) === color && capturedOwnerOf((r-2)*5 + c+2) === color) return true; } }
  return false;
}

function checkWinCapturedThreeInRow(playerColor){ if(checkCapturedRunOfThreeForColor(playerColor)){ endGame(playerColor); return true; } return false; }
function endGame(playerColor){
  updateStatus('');
  // freeze board UI by replacing nodes with clones (preserves visuals, removes listeners)
  board.querySelectorAll('.cell').forEach(cell => { cell.replaceWith(cell.cloneNode(true)); });
  // In multiplayer, publish the gameOver state so the other client shows defeat
  try{
    if(typeof multiplayerRoomId === 'string' && multiplayerRoomId){
      try{
        const snap = takeSnapshot();
        snap.gameOver = true; snap.winner = playerColor;
        // send authoritative end-game snapshot to room
        sendSnapshotToRoom(snap).catch(e=>{ console.warn('send endGame snapshot failed', e); });
      }catch(e){ console.warn('endGame: failed to send snapshot', e); }
    }
  }catch(e){ console.warn('endGame multiplayer publish err', e); }

  // show victory/defeat overlay locally
  try{ showEndOverlay(playerColor); }catch(e){ console.warn('victory UI error', e); }
}

// Victory UI + tune
let victoryNodes = null;
function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }
function showVictory(playerColor){
  const overlay = document.getElementById('victoryOverlay');
  const emoji = document.getElementById('victoryEmoji');
  const title = document.getElementById('victoryTitle');
  const txt = document.getElementById('victoryText');
  if(!overlay) return;
  // use selected emoji if available
  const redEmoji = (window.selectedEmoji && window.selectedEmoji.red) ? window.selectedEmoji.red : 'üê≤';
  const blueEmoji = (window.selectedEmoji && window.selectedEmoji.blue) ? window.selectedEmoji.blue : 'ü¶Ñ';
  emoji.textContent = playerColor === 'red' ? redEmoji : blueEmoji;
  const redName = (window.selectedEmojiNames && window.selectedEmojiNames.red) ? window.selectedEmojiNames.red : (EMOJI_TO_NAME[redEmoji] || 'Red Team');
  const blueName = (window.selectedEmojiNames && window.selectedEmojiNames.blue) ? window.selectedEmojiNames.blue : (EMOJI_TO_NAME[blueEmoji] || 'Blue Team');
  const redLabel = `Red ${redName}`;
  const blueLabel = `Blue ${blueName}`;
  title.textContent = `${playerColor === 'red' ? redLabel : blueLabel} Wins!`;
  txt.textContent = `Congrats ‚Äî ${playerColor === 'red' ? redLabel : blueLabel} captured three tiles in a row.`;
  overlay.classList.add('show'); overlay.removeAttribute('aria-hidden');
  // visually disable board interactions
  try{ board.style.pointerEvents = 'none'; }catch(e){}

  const restart = document.getElementById('victoryRestart');
  const close = document.getElementById('victoryClose');
  if(restart) restart.onclick = ()=>{
    try{ stopVictoryTune(); }catch(e){}
    overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); board.style.pointerEvents = '';
    // In multiplayer, start a rematch by resetting local board and sending the snapshot to room
    if(multiplayerRoomId){
      try{
        resetBoard();
        const snap = takeSnapshot();
        // clear any gameOver marker
        snap.gameOver = false; snap.winner = null;
        sendSnapshotToRoom(snap).catch(e=>{ console.warn('rematch send failed', e); });
        return;
      }catch(e){ console.warn('multiplayer rematch failed', e); }
    }
    // fallback single-player behavior
    resetBoard();
  };
  if(close) close.onclick = ()=>{ try{ stopVictoryTune(); }catch(e){} overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); board.style.pointerEvents = ''; };
}

// Unified end overlay for multiplayer: show victory to winner and defeat to loser
function showEndOverlay(winnerColor){
  const overlay = document.getElementById('victoryOverlay');
  const emoji = document.getElementById('victoryEmoji');
  const title = document.getElementById('victoryTitle');
  const txt = document.getElementById('victoryText');
  if(!overlay) return;
  const redEmoji = (window.selectedEmoji && window.selectedEmoji.red) ? window.selectedEmoji.red : 'üê≤';
  const blueEmoji = (window.selectedEmoji && window.selectedEmoji.blue) ? window.selectedEmoji.blue : 'ü¶Ñ';
  const redName = (window.selectedEmojiNames && window.selectedEmojiNames.red) ? window.selectedEmojiNames.red : (EMOJI_TO_NAME[redEmoji] || 'Red Team');
  const blueName = (window.selectedEmojiNames && window.selectedEmojiNames.blue) ? window.selectedEmojiNames.blue : (EMOJI_TO_NAME[blueEmoji] || 'Blue Team');
  const winnerLabel = winnerColor === 'red' ? `Red ${redName}` : `Blue ${blueName}`;
  const isWinner = (myPlayerColor && myPlayerColor === winnerColor);

  // Set emoji and texts
  emoji.textContent = winnerColor === 'red' ? redEmoji : blueEmoji;
  if(multiplayerRoomId){
    if(isWinner){
      title.textContent = `${winnerLabel} Wins!`;
      txt.textContent = `Congrats ‚Äî you captured three tiles in a row.`;
      try{ playVictoryTune(winnerColor); }catch(e){}
    } else {
      title.textContent = `Defeat`;
      txt.textContent = `${winnerLabel} captured three tiles in a row. Better luck next match.`;
    }
  } else {
    // single-player fall back to existing victory language
    title.textContent = `${winnerLabel} Wins!`;
    txt.textContent = `Congrats ‚Äî ${winnerLabel} captured three tiles in a row.`;
    try{ playVictoryTune(winnerColor); }catch(e){}
  }

  overlay.classList.add('show'); overlay.removeAttribute('aria-hidden');
  try{ board.style.pointerEvents = 'none'; }catch(e){}

  const restart = document.getElementById('victoryRestart');
  const close = document.getElementById('victoryClose');
  if(restart) restart.onclick = ()=>{
    try{ stopVictoryTune(); }catch(e){}
    // Single-player: immediate reset as before
    if(!multiplayerRoomId){
      overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); board.style.pointerEvents = '';
      resetBoard();
      return;
    }
    // Multiplayer: request a rematch and wait for opponent to agree
    try{
      _myRematchRequested = true;
      const remEl = document.getElementById('rematchStatus');
      if(remEl) remEl.textContent = 'You requested a rematch. Waiting for opponent...';
      if(restart){ restart.disabled = true; restart.textContent = 'Waiting...'; }
      sendRematchRequest().catch(e=>{ console.warn('rematch request failed', e); });
    }catch(e){ console.warn('rematch request err', e); }
  };
  if(close) close.onclick = ()=>{ try{ stopVictoryTune(); }catch(e){} overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); board.style.pointerEvents = ''; try{ if(_myRematchRequested){ withdrawMyRematchRequest(); _myRematchRequested = false; } }catch(e){} };
}

function hideVictory(){ const overlay = document.getElementById('victoryOverlay'); if(!overlay) return; overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); board.style.pointerEvents = ''; stopVictoryTune(); }

function playVictoryTune(playerColor){
  try{
    ensureAudioContext();
    if(victoryNodes) return; // already playing
    const master = audioCtx.createGain(); master.gain.value = 0.20; master.connect(audioCtx.destination);

    // upbeat tune: faster tempo, stacked melodic voices, and light percussion
    const bpm = 160; const beatMs = 60000 / bpm; const gap = Math.round(beatMs / 2); // 8th-note feel
    const melody = playerColor === 'red' ? [76,79,81,84,81,79,76,74] : [71,74,76,79,76,74,71,69];
    const leadDur = 0.18; const timeouts = []; const oscs = [];

    // percussion helper: short click/snare
    const noiseBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
    const nd = noiseBuf.getChannelData(0); for(let i=0;i<nd.length;i++) nd[i] = (Math.random()*2-1) * Math.exp(-i/2000);
    function playClap(tOffset=0){ const id = setTimeout(()=>{ const now = audioCtx.currentTime; const src = audioCtx.createBufferSource(); src.buffer = noiseBuf; const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.9, now + 0.005); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.14); src.connect(bp); bp.connect(g); g.connect(master); src.start(now); src.stop(now + 0.12); }, tOffset); timeouts.push(id); }

    // short bass thump under each downbeat
    function playThump(){ const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(80, now); const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.9, now + 0.004); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.26); o.connect(g); g.connect(master); o.start(now); o.stop(now + 0.28); }

    // lead voice (bright) + harmony voice (detuned)
    melody.forEach((m,i)=>{
      const t = i * gap;
      const id = setTimeout(()=>{
        const now = audioCtx.currentTime;
        // lead
        const o1 = audioCtx.createOscillator(); o1.type='sawtooth'; o1.frequency.value = midiToFreq(m);
        const g1 = audioCtx.createGain(); g1.gain.setValueAtTime(0.0001, now); g1.gain.linearRampToValueAtTime(0.28, now + 0.01); g1.gain.exponentialRampToValueAtTime(0.0001, now + leadDur);
        const hp1 = audioCtx.createBiquadFilter(); hp1.type='highpass'; hp1.frequency.value=220;
        o1.connect(hp1); hp1.connect(g1); g1.connect(master);
        o1.start(now); o1.stop(now + leadDur + 0.02);
        oscs.push(o1);
        // harmony (slightly detuned triangle)
        const o2 = audioCtx.createOscillator(); o2.type='triangle'; o2.frequency.value = midiToFreq(m - (i%2===0?0:12)) * (1.002 + Math.random()*0.004);
        const g2 = audioCtx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.linearRampToValueAtTime(0.18, now + 0.01); g2.gain.exponentialRampToValueAtTime(0.0001, now + leadDur);
        o2.connect(g2); g2.connect(master); o2.start(now); o2.stop(now + leadDur + 0.02); oscs.push(o2);

        // percussion and thump on downbeat (every 2 steps)
        if(i % 2 === 0){ playThump(); playClap(0); }
      }, t);
      timeouts.push(id);
    });

    // quick little arpeggiated sparkle underneath using high triangle
    const sparkleIds = [];
    for(let i=0;i<melody.length*2;i++){
      const id = setTimeout(()=>{ const now = audioCtx.currentTime; const note = melody[i % melody.length] + 12; const o = audioCtx.createOscillator(); o.type='triangle'; o.frequency.value = midiToFreq(note); const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.12, now + 0.008); g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12); o.connect(g); g.connect(master); o.start(now); o.stop(now + 0.14); oscs.push(o); }, i * (gap/2)); sparkleIds.push(id); timeouts.push(id); }

    // total duration and cleanup
    const totalMs = melody.length * gap + 600;
    const endId = setTimeout(()=>{ try{ master.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.4); setTimeout(()=>{ try{ master.disconnect(); }catch(e){} }, 600); }catch(e){} finally { victoryNodes = null; } }, totalMs);

    victoryNodes = { master, timeouts, oscs, endId };
  }catch(e){ console.warn('victory tune error', e); }
}

function stopVictoryTune(){ if(!victoryNodes) return; try{ const n = victoryNodes; if(n.timeouts) n.timeouts.forEach(id=>clearTimeout(id)); if(n.oscs) n.oscs.forEach(o=>{ try{o.stop();}catch(e){} }); if(n.master){ const now = audioCtx.currentTime; n.master.gain.cancelScheduledValues(now); n.master.gain.setValueAtTime(n.master.gain.value, now); n.master.gain.linearRampToValueAtTime(0.0001, now + 0.3); setTimeout(()=>{ try{ n.master.disconnect(); }catch(e){} }, 400); } }catch(e){} finally { victoryNodes = null; } }

function updateStatus(msg='') {
  const redEmoji = (window.selectedEmoji && window.selectedEmoji.red) ? window.selectedEmoji.red : 'üê≤';
  const blueEmoji = (window.selectedEmoji && window.selectedEmoji.blue) ? window.selectedEmoji.blue : 'ü¶Ñ';
  const redName = (window.selectedEmojiNames && window.selectedEmojiNames.red) ? window.selectedEmojiNames.red : (EMOJI_TO_NAME[redEmoji] || 'Red Team');
  const blueName = (window.selectedEmojiNames && window.selectedEmojiNames.blue) ? window.selectedEmojiNames.blue : (EMOJI_TO_NAME[blueEmoji] || 'Blue Team');
  const redLabel = `Red ${redName}`;
  const blueLabel = `Blue ${blueName}`;
  const scoreboardHTML = `
    <div style="display:flex;justify-content:center;align-items:center;gap:32px;font-size:1.7em;font-weight:bold;letter-spacing:1px;">
      <div style="display:flex;flex-direction:column;align-items:center;">
        <span style="background:rgba(255,255,255,0.06);color:#fff;padding:8px 18px;border-radius:8px;border:1px solid rgba(255,255,255,0.18);font-size:1.2em;font-weight:700;display:inline-block;">${redLabel}</span>
        <span style="background:rgba(255,255,255,0.06);color:#fff;padding:8px 24px;border-radius:8px;border:1px solid rgba(255,255,255,0.18);font-size:2.2em;font-weight:700;box-shadow:0 2px 8px rgba(0,0,0,0.10);margin-top:4px;">${scores.red}</span>
      </div>
      <span style="font-size:1.6em;color:#fff;background:rgba(255,255,255,0.06);padding:8px 18px;border-radius:8px;border:1px solid rgba(255,255,255,0.18);font-weight:700;">VS</span>
      <div style="display:flex;flex-direction:column;align-items:center;">
        <span style="background:rgba(255,255,255,0.06);color:#fff;padding:8px 18px;border-radius:8px;border:1px solid rgba(255,255,255,0.18);font-size:1.2em;font-weight:700;display:inline-block;">${blueLabel}</span>
        <span style="background:rgba(255,255,255,0.06);color:#fff;padding:8px 24px;border-radius:8px;border:1px solid rgba(255,255,255,0.18);font-size:2.2em;font-weight:700;box-shadow:0 2px 8px rgba(0,0,0,0.10);margin-top:4px;">${scores.blue}</span>
      </div>
    </div>
    <div style="margin-top:8px;font-size:1em;color:#fff;background:rgba(255,255,255,0.06);padding:6px 18px;border-radius:8px;border:1px solid rgba(255,255,255,0.18);font-weight:700;display:inline-block;">Turn: <b>${currentPlayer==='red'? redLabel : blueLabel}</b>${chainMode ? ' ‚Äî <span style="color:#ffd26b;font-weight:bold;">Chain Attack!</span>' : ''}${chainAllowLastMove ? ' ‚Äî <span style="color:#ffd26b;font-weight:bold;">Final move allowed</span>' : ''}</div>
  `;
  if (msg) {
    status.innerHTML = `<div>${msg}</div>` + scoreboardHTML;
    return;
  }
  status.innerHTML = scoreboardHTML;
}

function makePawn(color){
  const pawn = document.createElement('div');
  pawn.className = 'pawn';
  pawn.draggable = true;
  pawn.dataset.color = color;
  // default piece type is 'pawn' (can be promoted to 'bishop' or 'knight')
  pawn.dataset.piece = 'pawn';
  const face = document.createElement('span');
  face.className = 'pface';
  // Use selected emojis when available
  const redEmoji = (window.selectedEmoji && window.selectedEmoji.red) ? window.selectedEmoji.red : 'üê≤';
  const blueEmoji = (window.selectedEmoji && window.selectedEmoji.blue) ? window.selectedEmoji.blue : 'ü¶Ñ';
  face.textContent = color === 'red' ? redEmoji : blueEmoji;
  pawn.appendChild(face);

  function pauseIdle(){ pawn.classList.remove('idle'); }
  function resumeIdle(){ if(prefersReducedMotion) return; setTimeout(()=> { if(!pawn.classList.contains('dragging') && document.contains(pawn)) pawn.classList.add('idle'); }, 60); }

  let swipeStart = null;
  let swipeTimer = null;

  pawn.addEventListener('dragstart', (ev) => {
    pauseIdle();
    if(chainMode && chainPawn){
      const cpCell = chainPawn.parentElement;
  if(cpCell && availableCapturesFromCell(cpCell).length === 0){
        // Instead of immediately ending the chain, allow the chain pawn one
        // final non-capture decision. Mark that allowance and persist state.
        if(pawn === chainPawn){
          chainAllowLastMove = true;
          // snapshot this state (not counted as an extra move)
          recordSnapshot({ countAsMove: false });
        } else {
          // non-chain pawn may not move
          dragged = null;
          ev.preventDefault();
          resumeIdle();
          return;
        }
      }
      if (pawn !== chainPawn) { ev.preventDefault(); resumeIdle(); return; }
    }
    // In multiplayer, prevent dragging pawns that aren't owned by this client
    if(multiplayerRoomId){
      if(!myPlayerColor){ ev.preventDefault(); resumeIdle(); multiplayerStatus.textContent = 'Not assigned a player color'; setTimeout(()=> multiplayerStatus.textContent = '', 1500); return; }
      if(pawn.dataset.color !== myPlayerColor){ ev.preventDefault(); resumeIdle(); multiplayerStatus.textContent = "Cannot move opponent's pawns in multiplayer"; setTimeout(()=> multiplayerStatus.textContent = '', 1500); return; }
    }
    if (pawn.dataset.color !== currentPlayer) { ev.preventDefault(); resumeIdle(); return; }
    dragged = pawn; pawn.classList.add('dragging');
    try { ev.dataTransfer.setData('text/plain','drag'); } catch(e){}
  });
  pawn.addEventListener('dragend', () => { pawn.classList.remove('dragging'); resumeIdle(); });

  pawn.addEventListener('pointerdown', (ev) => {
    pauseIdle();
    if(chainMode && chainPawn){
      const cpCell = chainPawn.parentElement;
  if(cpCell && availableCapturesFromCell(cpCell).length === 0){
        if(pawn === chainPawn){
          chainAllowLastMove = true;
          recordSnapshot({ countAsMove: false });
        } else {
          resumeIdle();
          return;
        }
      }
      if (pawn !== chainPawn) { resumeIdle(); return; }
    }
    // In multiplayer, prevent interacting with pawns that aren't owned by this client
    if(multiplayerRoomId){
      if(!myPlayerColor){ resumeIdle(); multiplayerStatus.textContent = 'Not assigned a player color'; setTimeout(()=> multiplayerStatus.textContent = '', 1500); return; }
      if(pawn.dataset.color !== myPlayerColor){ resumeIdle(); multiplayerStatus.textContent = "Cannot move opponent's pawns in multiplayer"; setTimeout(()=> multiplayerStatus.textContent = '', 1500); return; }
    }
    if (pawn.dataset.color !== currentPlayer) { resumeIdle(); return; }

    try { pawn.setPointerCapture && pawn.setPointerCapture(ev.pointerId); } catch(e){}
    dragged = pawn;
    pawn.classList.add('dragging');

    swipeStart = { x: ev.clientX, y: ev.clientY, t: Date.now(), pointerId: ev.pointerId };
    clearTimeout(swipeTimer);
    swipeTimer = setTimeout(()=> { swipeStart = null; }, SWIPE_MAX_TIME + 40);
  });

  pawn.addEventListener('pointermove', (ev) => {
    if(!swipeStart) return;
    if(swipeStart.pointerId != null && ev.pointerId !== swipeStart.pointerId) return;
  });

  pawn.addEventListener('pointerup', (ev) => {
    try { pawn.releasePointerCapture && pawn.releasePointerCapture(ev.pointerId); } catch(e){}
    if(swipeStart && swipeStart.pointerId != null && ev.pointerId === swipeStart.pointerId){
      const dt = Date.now() - swipeStart.t;
      const dx = ev.clientX - swipeStart.x;
      const dy = ev.clientY - swipeStart.y;
      const dist = Math.hypot(dx, dy);
      if(dist >= SWIPE_MIN_DIST && dt <= Math.max(SWIPE_MAX_TIME, dt)){
        const delta = angleToCellDelta(dx, dy);
        if(delta){
          const fromCell = pawn.parentElement;
          if(fromCell){
            const fromIdx = Number(fromCell.dataset.index);
            const fx = fromIdx % 5, fy = Math.floor(fromIdx / 5);
            const tx = fx + delta.dx, ty = fy + delta.dy;
            if(tx >= 0 && tx < 5 && ty >= 0 && ty < 5){
              const toIdx = ty * 5 + tx;
              const targetCell = board.children[toIdx];
              if(targetCell){
                const existing = targetCell.querySelector('.pawn');
                if(chainMode && chainPawn && Math.abs(delta.dx) === 1 && Math.abs(delta.dy) === 1){
                  if(!(existing && existing.dataset.color !== pawn.dataset.color)){
                    // allow diagonal non-capture swipe during a chain if one of the
                    // orthogonal adjacent tiles is empty (so the pawn can step around)
                    const fromIdx = Number(pawn.parentElement.dataset.index);
                    const fx = fromIdx % 5, fy = Math.floor(fromIdx / 5);
                    const tx = fx + delta.dx, ty = fy + delta.dy;
                    const adj1 = board.children[fy * 5 + tx];
                    const adj2 = board.children[ty * 5 + fx];
                    const adj1Empty = adj1 && !adj1.querySelector('.pawn');
                    const adj2Empty = adj2 && !adj2.querySelector('.pawn');
                    // allow stepping back to the previous square of the chain pawn
                    const toIdx = ty * 5 + tx;
                    if(toIdx === chainPrevIdx){
                      // permitted if the previous square is empty (it should be empty because pawn moved)
                    } else if(!(adj1Empty || adj2Empty || chainAllowLastMove)){
                      swipeStart = null;
                      setTimeout(()=> pawn.classList.remove('dragging'), 40);
                      resumeIdle();
                      return;
                    }
                  }
                }
                const dxCells = Math.abs(tx - fx), dyCells = Math.abs(ty - fy);
                if(isValidMove(dxCells, dyCells, pawn, fromIdx, toIdx) || canDoubleStep(pawn, fromIdx, toIdx)){
                  try { handleDrop(new Event('swipe-drop'), targetCell); } catch(e){}
                }
              }
            }
          }
        }
      }
    }
    swipeStart = null;
    clearTimeout(swipeTimer);
    setTimeout(()=> pawn.classList.remove('dragging'),40);
    resumeIdle();
    pawn.style.transform = '';
  });

  pawn.__enableIdleAfterAppend = () => enableIdleAfterFrame(pawn);

  return pawn;
}

// Init
function init(){
  board.innerHTML = '';
  for(let i=0;i<25;i++){
    const cell = document.createElement('div');
    cell.className = 'cell ' + (((Math.floor(i/5) + i%5) % 2 === 0) ? 'white' : 'black');
    cell.dataset.index = i;
    cell.addEventListener('click', ()=> onCellClick(cell));
    cell.addEventListener('dragover', e=>e.preventDefault());
    cell.addEventListener('drop', e=> handleDrop(e, cell));
    board.appendChild(cell);
  }
  resetBoard();
}

resetBtn.addEventListener('click', () => {
  // In multiplayer, use Reset as a rematch request instead of immediate reset
  if(multiplayerRoomId){
    try{
      _myRematchRequested = true;
      const remEl = document.getElementById('rematchStatus');
      if(remEl) remEl.textContent = 'You requested a rematch. Waiting for opponent...';
      try{ resetBtn.disabled = true; resetBtn.textContent = 'Waiting...'; }catch(e){}
      sendRematchRequest().catch(e=>{ console.warn('reset->rematch request failed', e); });
    }catch(e){ console.warn('reset rematch err', e); }
    return;
  }
  resetBoard();
});
undoBtn.addEventListener('click', () => undo());
redoBtn.addEventListener('click', () => redo());

// New button: refresh the page
const newBtn = document.getElementById('newBtn');
if(newBtn){ newBtn.addEventListener('click', ()=> { try{ window.location.reload(); }catch(e){ location.reload(); } }); }

// AI toggle UI wiring (now an accessible on/off toggle)
const aiToggleBtn = document.getElementById('aiToggleBtn');
if(aiToggleBtn){
  aiToggleBtn.classList.add('toggle-btn');
  function setAiBtnState(){
    aiToggleBtn.setAttribute('aria-pressed', aiEnabled ? 'true' : 'false');
    // Display difficulty name when AI is enabled.
    aiToggleBtn.textContent = aiEnabled ? ('AI: ' + (aiDifficulty === 'hard' ? 'Hard' : 'Easy')) : 'AI: Off';
    aiToggleBtn.classList.toggle('toggle-on', aiEnabled);
    aiToggleBtn.classList.toggle('toggle-off', !aiEnabled);
  }
  // initialize state
  setAiBtnState();
  aiToggleBtn.addEventListener('click', ()=>{
    // Cycle states: Off -> Hard -> Easy -> Off
    if(!aiEnabled){
      // Turn AI on with default Hard
      aiEnabled = true;
      aiDifficulty = 'hard';
    } else if(aiEnabled && aiDifficulty === 'hard'){
      // Switch to Easy while staying enabled
      aiDifficulty = 'easy';
      aiEnabled = true;
    } else {
      // Currently enabled && easy -> turn off
      aiEnabled = false;
    }
    // if turning off, cancel any scheduled AI timer immediately
    if(!aiEnabled && _aiTimer){ clearTimeout(_aiTimer); _aiTimer = null; }
    setAiBtnState();
    // when enabled and it's AI's turn, schedule it
    if(aiEnabled) scheduleAiIfNeeded(320);
  });
}
// (Difficulty button removed ‚Äî aiToggleBtn now cycles: Hard -> Easy -> Off)


// Rules Overlay HTML
const rulesOverlay = document.createElement('div');
rulesOverlay.id = 'rulesOverlay';
rulesOverlay.className = 'rules-overlay';
rulesOverlay.setAttribute('aria-hidden', 'true');
rulesOverlay.innerHTML = `
  <div class="rules-modal">
    <div class="rules-box" style="min-width:420px; min-height:160px; position:relative;">
      <button class="rules-close" id="rulesCloseBtn" aria-label="Close Rules">&times;</button>
      <h1>Welcome to Tic-Tac-Attack! üëã</h1>
      <p>A game that combines pawns from chess with tic-tac-toe! Here are the rules. ‚ôüÔ∏è</p>
      <ol>
        <li>) You are allowed one move per turn unless in a chain attack. ‚û°Ô∏è</li>
        <li>) Capturing a piece allows that piece to capture/move again. Causing a chain attack. ‚öîÔ∏è</li>
        <li>) Pawns may move one space in any direction but can only capture diagonally. üéØ</li>
        <li>) Pawns may move up two squares on their first move. (Just like in chess) ‚úåÔ∏è</li>
        <li>) You can only have five pawns out at a time. (Click on your starting row to spawn a new pawn) üëÅÔ∏è</li>
        <li>) Getting a pawn to the opponent's back row allows for promotion. (Transform your pawn into a Bishop or Knight) üëë</li>
        <li>) Capture three pawns in a row to win. (Just like in Tic-Tac-Toe) üèÜ</li>
        <li>) If the game ends a draw the person with the most points wins. (Points are based upon enemy pawns captured) üèÄ</li>
      </ol>
    </div>
  </div>
`;
document.body.appendChild(rulesOverlay);

// Credits Overlay HTML (visually identical to rules overlay but no text)
const creditsOverlay = document.createElement('div');
creditsOverlay.id = 'creditsOverlay';
creditsOverlay.className = 'rules-overlay';
creditsOverlay.setAttribute('aria-hidden', 'true');
creditsOverlay.innerHTML = `
  <div class="rules-modal">
    <div class="credits-box" style="min-width:320px; min-height:120px; position:relative;">
      <button class="rules-close" id="creditsCloseBtn" aria-label="Close Credits">&times;</button>
      <h1 style="margin-top:0;">Credits</h1>
      <p style="margin:8px 0 6px 0;"><strong>Developer:</strong> Edward Frosch A.K.A. Roachclip ü™≥</p>
  <p style="margin:6px 0;"><strong>Bug Tester:</strong> Istillloveyou ‚ù§Ô∏è</p>
  <p style="margin:6px 0;"><strong>Bug Tester:</strong> Pyranto üî•</p>
  <p style="margin:6px 0;"><strong>Bug Tester:</strong> Gurr23 üåà</p>
    </div>
  </div>
`;
document.body.appendChild(creditsOverlay);

// Rules Overlay CSS
const rulesStyle = document.createElement('style');
rulesStyle.textContent = `
  .rules-overlay {
    position: fixed; inset: 0; z-index: 9998; display: flex; align-items: center; justify-content: center;
    background: rgba(6,6,6,0.68); opacity: 0; pointer-events: none; transition: opacity 220ms ease;
  }
  .rules-overlay.show { opacity: 1; pointer-events: auto; }
  .rules-modal {
    background: #000; color: #fff; border-radius: 14px; box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    padding: 28px 28px 20px 28px;
    /* size the modal to fit its text content while respecting small viewports */
    width: max-content;
    display: inline-block;
    text-align: left;
    max-width: 92vw;
    font-family: system-ui,Segoe UI,Arial;
    position: relative;
    animation: rulesPopIn 0.22s cubic-bezier(.6,1.6,.4,1) 1;
  }
  .rules-modal h1 { margin-top: 0; font-size: 1.5em; }
  .rules-modal ol { margin-top: 8px; }
  .rules-close {
    position: absolute; top: 10px; right: 12px; background: none; border: none; font-size: 1.8em; color: #ddd; cursor: pointer;
    transition: color 0.18s; z-index: 3;
  }
  .rules-close:hover { color: #fff; }
  @keyframes rulesPopIn {
    0% { transform: scale(0.92) translateY(24px); opacity: 0; }
    100% { transform: scale(1) translateY(0); opacity: 1; }
  }
  /* Curved white border around credits text */
  #creditsOverlay .credits-box{
    position: relative;
    border: 1px solid rgba(255,255,255,0.92);
    border-radius: 14px;
    padding: calc(14px * var(--scale)) calc(16px * var(--scale));
    background: rgba(255,255,255,0.02);
    text-align: center;
    min-width: 380px;
    min-height: 160px;
  }
  #creditsOverlay .credits-box h1{
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.25em;
    text-decoration: underline;
    text-decoration-thickness: 2px;
    text-underline-offset: 6px;
  }
  /* confetti elements that float up and fade */
  .credits-confetti-container{ position: absolute; inset: 0; pointer-events: none; overflow: hidden; }
  .credit-confetti{
    position: absolute;
    bottom: 8%;
    transform: translateY(0) rotate(0deg);
    opacity: 0;
    display: inline-block;
    animation: confettiRise 2.6s ease-in forwards;
  }
  @keyframes confettiRise{
    0%{ opacity: 0; transform: translateY(0) rotate(0deg); }
    10%{ opacity: 1; }
    100%{ opacity: 0; transform: translateY(-220px) rotate(420deg); }
  }
  /* Make the credits modal slightly larger and more spacious on wider viewports */
  #creditsOverlay .rules-modal{
    width: min(560px, 92vw);
    padding: 36px;
  }
  /* Curved white border for rules content (match credits box styling) */
  #rulesOverlay .rules-box{
    position: relative;
    border: 1px solid rgba(255,255,255,0.92);
    border-radius: 14px;
    padding: calc(14px * var(--scale)) calc(16px * var(--scale));
    background: rgba(255,255,255,0.02);
    text-align: left;
  }
  #rulesOverlay .rules-box h1{ margin-top: 0; margin-bottom: 8px; }
`;
document.head.appendChild(rulesStyle);

// Theme button wiring ‚Äî implement a lightweight 'snow' theme
const themeBtn = document.getElementById('themeBtn');
if(themeBtn){
  // ensure a theme state exists; default theme is 'flowers'
  // default to the 'snow' theme on first load
  if(!window.currentTheme) window.currentTheme = 'snow';

  // inject theme CSS for snow and space themes (scoped to body classes)
  if(!document.getElementById('themeStyles')){
    const ts = document.createElement('style');
    ts.id = 'themeStyles';
    ts.textContent = `
      /* Theme 'snow' uses a dark blue gradient for a night/snow look */
      body.theme-snow {
        background: linear-gradient(180deg, #021024 0%, #02284a 45%, #06305f 100%);
      }
      /* Theme 'space' uses a very dark grey gradient to emulate deep space */
      body.theme-space {
        background: linear-gradient(180deg, #0b0b0b 0%, #111216 45%, #19191c 100%);
      }
    `;
    document.head.appendChild(ts);
  }

  function setTheme(t){
    window.currentTheme = t || 'flowers';
    // clear any theme classes first
    document.body.classList.remove('theme-snow');
    document.body.classList.remove('theme-space');
    if(window.currentTheme === 'snow'){
      document.body.classList.add('theme-snow');
      window.currentFlowerEmojis = ['‚ùÑÔ∏è'];
    } else if(window.currentTheme === 'space'){
      document.body.classList.add('theme-space');
      // use a single star emoji for space theme
      window.currentFlowerEmojis = ['‚≠ê'];
    } else {
      // Flowers theme: use default floral emojis
      window.currentFlowerEmojis = null;
    }
    // reinitialize flowers to pick up emoji change
    try{ if(typeof initFlowers === 'function') initFlowers(); }catch(e){}
    // keep the button label static
    themeBtn.textContent = 'Theme';
  }

  // cycle theme on click: Flowers -> Snow -> Space -> Flowers
  themeBtn.addEventListener('click', ()=>{
    const next = window.currentTheme === 'flowers' ? 'snow' : (window.currentTheme === 'snow' ? 'space' : 'flowers');
    setTheme(next);
  });

  // ensure the button always reads 'Theme'
  themeBtn.textContent = 'Theme';
  // apply the initial theme immediately so the page loads using the default
  // (e.g., 'snow') instead of waiting for the user to click the button.
  try{ setTheme(window.currentTheme); }catch(e){ /* ignore if setTheme not defined */ }
}

// Rules Overlay JS
const rulesBtn = document.getElementById('rulesBtn');
if(rulesBtn){
  rulesBtn.addEventListener('click', ()=>{
    rulesOverlay.classList.add('show');
    rulesOverlay.setAttribute('aria-hidden', 'false');
  });
}
document.getElementById('rulesCloseBtn').onclick = ()=>{
  rulesOverlay.classList.remove('show');
  rulesOverlay.setAttribute('aria-hidden', 'true');
};

const creditsBtn = document.getElementById('creditsBtn');
if(creditsBtn){
  creditsBtn.addEventListener('click', ()=>{
    const el = document.getElementById('creditsOverlay');
    if(!el) return;
    // show overlay and launch a small confetti animation
    el.classList.add('show');
    el.setAttribute('aria-hidden', 'false');
    launchCreditsConfetti(el);
  });
}
const creditsClose = document.getElementById('creditsCloseBtn');
if(creditsClose){
  creditsClose.onclick = ()=>{
    const el = document.getElementById('creditsOverlay');
    if(!el) return;
    el.classList.remove('show');
    el.setAttribute('aria-hidden', 'true');
    clearCreditsConfetti(el);
  };
}

// Small confetti animation for the credits overlay
function launchCreditsConfetti(overlay){
  try{
    clearCreditsConfetti(overlay);
    const container = document.createElement('div');
    container.className = 'credits-confetti-container';
    // create a handful of emoji confetti
    const emojis = ['‚ú®','ü™∂','üéâ','‚≠ê','üåü','ü™≥'];
    for(let i=0;i<28;i++){
      const s = document.createElement('span');
      s.className = 'credit-confetti';
      s.textContent = emojis[Math.floor(Math.random()*emojis.length)];
      // randomize starting position
      s.style.left = (10 + Math.random()*80) + '%';
      s.style.animationDelay = (Math.random()*0.6) + 's';
      s.style.fontSize = (14 + Math.random()*18) + 'px';
      container.appendChild(s);
    }
    overlay.appendChild(container);
    // store reference for cleanup
    overlay._confettiContainer = container;
  }catch(e){ console.warn('confetti error', e); }
}

function clearCreditsConfetti(overlay){
  try{
    if(!overlay) return;
    const c = overlay._confettiContainer;
    if(c && c.parentNode) c.parentNode.removeChild(c);
    overlay._confettiContainer = null;
  }catch(e){ /* ignore */ }
}

init();
// show the start mode chooser immediately after init so the player picks a mode
if (typeof showStartModeOverlay === 'function') showStartModeOverlay();
if (typeof initFlowers === 'function') initFlowers();
window.addEventListener('load', () => { if (typeof initFlowers === 'function') initFlowers(); });

// debug helpers
window.__PE = { undoStack, redoStack, takeSnapshot: ()=> undoStack[undoStack.length-1], applySnapshot, countPawns };
</script>
</body>
</html>
